<?xml version="1.0" encoding="UTF-8"?>
<fpdoc-descriptions>
  <package name="lcl">
    <!--
    ====================================================================
      Forms
    ====================================================================
    -->
    <module name="Forms">
      <short>
        Contains types and classes used to implement Forms, which are the basis for the Lazarus Graphical User Interface
      </short>
      <descr/>
      <!-- unresolved type references Visibility: default -->
      <element name="Classes"/>
      <element name="SysUtils"/>
      <element name="Types"/>
      <element name="TypInfo"/>
      <element name="Math"/>
      <element name="CustApp"/>
      <element name="LCLStrConsts"/>
      <element name="LCLTypes"/>
      <element name="LCLProc"/>
      <element name="LCLIntf"/>
      <element name="LCLVersion"/>
      <element name="LCLClasses"/>
      <element name="InterfaceBase"/>
      <element name="LResources"/>
      <element name="GraphType"/>
      <element name="Graphics"/>
      <element name="Menus"/>
      <element name="LMessages"/>
      <element name="CustomTimer"/>
      <element name="ActnList"/>
      <element name="ClipBrd"/>
      <element name="HelpIntfs"/>
      <element name="Controls"/>
      <element name="ImgList"/>
      <element name="Themes"/>
      <element name="LazFileUtils"/>
      <element name="LazUTF8"/>
      <element name="Maps"/>
      <element name="IntegerList"/>
      <element name="LazMethodList"/>
      <element name="LazLoggerBase"/>
      <element name="LazUtilities"/>
      <element name="UITypes"/>
      <element name="gettext"/>
      <!-- procedure type Visibility: default -->
      <element name="TProcedure">
        <short>The type of a procedure that takes no arguments</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TProcedureOfObject">
        <short>The type of a method that takes no arguments</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TPosition">
        <short>Represents the Position and Size of a Form on Screen</short>
        <descr>
          <p>poDesigned - The Form appears exactly as it is positioned and sized in the Form Designer</p>
          <p>poDefault - The window manager decides how the form is to appear, in a default position and size</p>
          <p>poDefaultPosOnly - keeps the Designed size, but position determined by windowmanager</p>
          <p>poDefaultSizeOnly - keeps the Designed position, but size determined by windowmanager</p>
          <p>poScreenCenter - Centers the form on screen</p>
          <p>poDeskTopCenter - Centers the form on desktop</p>
          <p>poMainFormCenter - Centers the Form on the Main Form</p>
          <p>poOwnerFormCenter - Centers the Form on Owner form</p>
          <p>poWorkAreaCenter - Centers the Form on working area</p>
        </descr>
        <seealso/>
      </element>
      <element name="TPosition.poDesigned">
        <short>The Form appears exactly as it is positioned and sized in the Form Designer.
        </short>
      </element>
      <element name="TPosition.poDefault">
        <short>
          The window manager decides how the form is to appear, in a default position and size.
        </short>
      </element>
      <element name="TPosition.poDefaultPosOnly">
        <short>
          Keeps the designed form size, but position determined by windowmanager.
        </short>
      </element>
      <element name="TPosition.poDefaultSizeOnly">
        <short>
          Keeps the designed form position, but size determined by windowmanager.
        </short>
      </element>
      <element name="TPosition.poScreenCenter">
        <short>Centers the form on screen.
        </short>
      </element>
      <element name="TPosition.poDesktopCenter">
        <short>
          Centers the form on the desktop (not recommended, use poScreenCenter).
        </short>
      </element>
      <element name="TPosition.poMainFormCenter">
        <short>Centers the form on the Main Form</short>
      </element>
      <element name="TPosition.poOwnerFormCenter">
        <short>Centers the form on its Owner form</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TWindowState">
        <short>Represents the actual State of the window on the screen</short>
        <descr>
          <p>The actual meaning of each value depends on the platform:</p>
          <dl>
            <dt>Windows and Mac OS X</dt>
            <dd>These operating systems support all values.</dd>
            <dt>X11</dt>
            <dd>The window state is a hint sent to the Window Manager, so more primitive Window Managers might ignore these hints.</dd>
            <dt>Windows CE</dt>
            <dd>In Windows CE platforms where Application.ApplicationType = atKeyPadDevice or atPDA (like in Windows Phone, PocketPC and Windows Mobile), wsMinimized and wsNormal are understood as wsMaximized, which is the normal state for windows in this platform. An exception are windows with BorderStyle=bsDialog or bsNone, which are allowed to have a custom position and size. For more information please read http://wiki.lazarus.freepascal.org/Windows_CE_Development_Notes#Positioning_and_size_of_Dialogs_and_Forms</dd>
            <dt>Android</dt>
            <dd>In this platform windows are always fullscreen.</dd>
          </dl>
          <p>The valid values for this enumerated type are:</p>
          <dl>
            <dt>wsNormal</dt>
            <dd>The window appears normal</dd>
            <dt>wsMinimized</dt>
            <dd>The window is minimized and is not shown in the screen, but only in the taskbar</dd>
            <dt>wsMaximized</dt>
            <dd>The window appears maximized</dd>
            <dt>wsFullScreen</dt>
            <dd>The window appears in full screen mode, as much as allowed by the platform</dd>
          </dl>
        </descr>
        <seealso/>
      </element>
      <element name="TWindowState.wsNormal">
        <short>Neither maximized nor minimized</short>
      </element>
      <element name="TWindowState.wsMinimized">
        <short>The window is minimized and is not shown in the screen, but only in the taskbar</short>
      </element>
      <element name="TWindowState.wsMaximized">
        <short>The window appears maximized. The exact behavior is up to the window manager, but usually the window appear occupying all of the work area of a monitor.</short>
        <notes><note>to the full monitor?</note></notes>
      </element>
      <element name="TWindowState.wsFullScreen">
        <short>
          The window appears in full screen mode, when allowed by the platform. It will, for example, attempt to appear on the top of taskbars and other static platform user interface elements.
        </short>
        <notes><note>?</note></notes>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TCloseAction">
        <short>What should happen when a form is closed</short>
        <descr/>
        <seealso>
          <link id="TCustomForm.OnClose">TCustomForm.OnClose</link>
        </seealso>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCloseAction.caNone">
        <short>Do nothing</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCloseAction.caHide">
        <short>The form is hidden</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCloseAction.caFree">
        <short>The form is destroyed</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TCloseAction.caMinimize">
        <short>The form is minimized</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomHintAction">
        <short>Action taken when a new value is assigned to <link id="TApplication.Hint"/>, and no OnHint handler is available</short>
        <descr>
        </descr>
        <seealso/>
        <notes><note>!?</note></notes>
      </element>
      <!-- property Visibility: published -->
      <element name="TCustomHintAction.Hint" link="#LCL.ActnList.TCustomAction.Hint">
        <short>The new Hint text</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TScrollBarKind">
        <short>The orientation of a ScrollBar</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TScrollBarKind.sbHorizontal">
        <short>Horizontal scrollbar</short>
      </element>
      <!-- enumeration value Visibility: default -->
      <element name="TScrollBarKind.sbVertical">
        <short>Vertical scrollbar</short>
      </element>
      <!-- range type Visibility: default -->
      <element name="TScrollBarInc">
        <short>The range of scrollbar increments</short>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TScrollBarStyle">
        <short>Scrollbar style flags</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScrollBarStyle.ssRegular">
        <short>Default</short>
        <notes><note>what's this?</note></notes>
      </element>
      <element name="TScrollBarStyle.ssFlat">
        <short>Scrollbar appears flat</short>
      </element>
      <element name="TScrollBarStyle.ssHotTrack">
        <short>Scrollbar sends HotTrack messages</short>
        <notes><note>Not used in the current LCL version.</note></notes>
      </element>
      <!-- object Visibility: default -->
      <element name="EScrollBar">
        <short>Class for exception in <link id="TControlScrollBar"/></short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TControlScrollBar">
        <short>Type of a scrollbar in a <link id="#lcl.Forms.TScrollingWinControl"/></short>
        <descr>
          <p>
            Scrollable controls supply their own <b>integrated</b> scrollbars, one for horizontal and one for vertical scrolling. This class allows access to (one of) these integrated scrollbars.
          </p>
          <p>
            A scrollable control has both a physical (visible) client size, and a logical (virtual) client size.
          </p>
          <p>
            The <var>Range</var> property reflects the total virtual client size, in pixels.
          </p>
          <p>
            The <var>Page</var> property corresponds to physical (visible) client size, in pixels, excluding the scrollbars. It also determines the size of the slider, relative to the total Range.
          </p>
          <p>
            The <var>Position</var> property reflects the virtual origin of the visible client area, equivalent to the top coordinate of the slider. The Position can be changed by the user or by code.
          </p>
          <p>
            Scrollbars usually appear only when Range is higher than Page, i.e. when not the entire content can be shown at the same time. See the ScrollBar property of the scrolling control for details.
          </p>
        </descr>
        <seealso>
          <link id="TScrollingWinControl"/>
          <link id="TScrollBox"/>
          <link id="TCustomForm"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlScrollBar.FAutoRange">
        <short>
          The virtual scroll range (FRange - ClientSize), at least zero (never negative)
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TControlScrollBar.FIncrement" link="TControlScrollBar.Increment"/>
      <element name="TControlScrollBar.FKind" link="TControlScrollBar.Kind"/>
      <element name="TControlScrollBar.FPage" link="TControlScrollBar.Page"/>
      <element name="TControlScrollBar.FRange" link="TControlScrollBar.Range"/>
      <element name="TControlScrollBar.FSmooth" link="TControlScrollBar.Smooth"/>
      <element name="TControlScrollBar.FTracking" link="TControlScrollBar.Tracking"/>
      <element name="TControlScrollBar.FVisible" link="TControlScrollBar.Visible"/>
      <!-- variable Visibility: private -->
      <element name="TControlScrollBar.FOldScrollInfo"/>
      <!-- variable Visibility: private -->
      <element name="TControlScrollBar.FOldScrollInfoValid"/>
      <!-- variable Visibility: protected -->
      <element name="TControlScrollBar.FControl">
        <short>The associated <link id="TScrollingWinControl"/></short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.FPosition" link="TControlScrollBar.Position"/>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.ControlHandle">
        <short>The Handle of the associated <link id="TScrollingWinControl"/></short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.ControlHandle.Result">
        <short>The handle for the associated control</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetAutoScroll">
        <short>The AutoScroll state of the associated <link id="TScrollingWinControl"/></short>
        <descr>
          <remark>
            Please note: GetAutoScroll is not used as the read access specifier for the AutoScroll property. It is used in methods to ensure that the class reflects the current state for its associated Control.
          </remark>
        </descr>
        <seealso>
          <link id="TControlScrollBar.Control"/>
          <link id="TControlScrollBar.AutoScroll"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.GetAutoScroll.Result">
        <short>
          True when the Control for the class instance has set its AutoScroll property
        </short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetIncrement" link="TControlScrollBar.Increment"/>
      <element name="TControlScrollBar.GetIncrement.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetPage" link="TControlScrollBar.Page"/>
      <element name="TControlScrollBar.GetPage.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetPosition" link="TControlScrollBar.Position"/>
      <element name="TControlScrollBar.GetPosition.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetRange" link="TControlScrollBar.Range"/>
      <element name="TControlScrollBar.GetRange.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetSize" link="TControlScrollBar.Size"/>
      <element name="TControlScrollBar.GetSize.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.GetSmooth" link="TControlScrollBar.Smooth"/>
      <element name="TControlScrollBar.GetSmooth.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.HandleAllocated">
        <short>True when the associated <link id="TScrollingWinControl"/> has a handle allocated</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.HandleAllocated.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.IsRangeStored" link="TControlScrollBar.Range"/>
      <element name="TControlScrollBar.IsRangeStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.AutoCalcRange">
        <short>Determines the scrollbar Range, using the physical and virtual size for the associated control</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.ControlUpdateScrollBars">
        <short>Notifies the associated Control of changes</short>
        <descr/>
        <seealso>
          <link id="TScrollingWinControl.UpdateScrollBars"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.InternalSetRange">
        <short>Checks and updates the new range for scrollbars in the Control</short>
        <descr/>
        <seealso>
          <link id="TControlScrollBar.ControlUpdateScrollBars"/>
          <link id="TScrollingWinControl.UpdateScrollBars"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.InternalSetRange.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.ScrollHandler">
        <short>Handler for the ScrollBar movement messages</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.ScrollHandler.Message">
        <short>Message examined in the method</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.SetIncrement" link="TControlScrollBar.Increment"/>
      <element name="TControlScrollBar.SetIncrement.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.SetPage" link="TControlScrollBar.Page"/>
      <element name="TControlScrollBar.SetPage.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.SetPosition" link="TControlScrollBar.Position"/>
      <element name="TControlScrollBar.SetPosition.Value">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.SetRange" link="TControlScrollBar.Range"/>
      <element name="TControlScrollBar.SetRange.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.SetSize" link="TControlScrollBar.Size"/>
      <element name="TControlScrollBar.SetSize.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.SetSmooth" link="TControlScrollBar.Smooth"/>
      <element name="TControlScrollBar.SetSmooth.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.SetTracking" link="TControlScrollBar.Tracking"/>
      <element name="TControlScrollBar.SetTracking.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.SetVisible" link="TControlScrollBar.Visible"/>
      <element name="TControlScrollBar.SetVisible.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.UpdateScrollBar">
        <short>
          Updates the state and position for the scroll bar in the associated Control
        </short>
        <descr>
          <p>
            <var>UpdateScrollBar</var> is a procedure used to update the state and position for the scroll bar in the associated <var>Control</var>.
          </p>
          <p>
            When <var>Control</var> is a <var>TScrollingWinControl</var> instance, <var>TScrollInfo</var> is captured using the <var>Range</var>, <var>Position</var>, and <var>Page</var> properties. The scroll bar information is applied to the associated control by calling <var>SetScrollInfo</var>.
          </p>
          <remark>
            Please note: <var>TScrollInfo</var> values are not applied when a handle has not been allocated for the control, or when <var>Control</var> is not a <var>TScrollingWinControl</var> class instance.
          </remark>
          <p>
            <var>UpdateScrollBar</var> calls <var>SetPosition</var> to apply the current value in <var>Position</var> to a visible scroll bar in the class instance. When <var>Control</var> is a <var>TScrollingWinControl</var> instance, the <var>Smooth</var> property is used to determine if <var>Increment</var> needs to be adjusted to a value that is 10% of the <var>Page</var> size for the control.
          </p>
          <p>
            <var>UpdateScrollBar</var> is used in the implementation of the <var>ControlUpdateScrollBars</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.Increment"/>
          <link id="TControlScrollBar.Page"/>
          <link id="TControlScrollBar.Smooth"/>
          <link id="TControlScrollBar.Range"/>
          <link id="TControlScrollBar.ControlUpdateScrollBars"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TControlScrollBar.InvalidateScrollInfo">
        <short>Renders scroll information invalid for the control</short>
        <descr/>
        <seealso/>
        <notes><note>usage?</note></notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.GetHorzScrollBar">
        <short>Get the horizontal scrollbar for the Control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.GetHorzScrollBar.Result">
        <short>
        </short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.GetVertScrollBar">
        <short>Get the vertical scrollbar for the Control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.GetVertScrollBar.Result">
        <short>
          Scrollbar for the control, or Nil when not a TScrollingWinControl descendant
        </short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TControlScrollBar.ScrollBarShouldBeVisible">
        <short>Determines whether a scrollbar is required</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TControlScrollBar.ScrollBarShouldBeVisible.Result">
        <short>True when Visible and Range higher than Page</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TControlScrollBar.Create">
        <short>Creates a scrollbar object for AControl</short>
        <descr/>
        <seealso>
          <link id="#rtl.System.TObject.Create">TObject.Create</link>
        </seealso>
      </element>
      <element name="TControlScrollBar.Create.AControl">
        <short>The windowed control in which the scroll bar is found</short>
      </element>
      <element name="TControlScrollBar.Create.AKind">
        <short>The scrollbar orientation</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TControlScrollBar.Assign">
        <short>If Source is a <var>TControlScrollBar</var>, copies properties to itself, else performs inherited <var>Assign</var>
        </short>
        <descr>
          <p>
            Assigns the contents of the source object to the current object; in particular finds the increment, position, range and whether smooth scrolling is to  be feature and whether the scroll bar is visible.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TPersistent.Assign"/>
        </seealso>
      </element>
      <element name="TControlScrollBar.Assign.Source">
        <short>
        </short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.IsScrollBarVisible">
        <short>Determines the current widget state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.IsScrollBarVisible.Result">
        <short>True if scrollbar is visible</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.ScrollPos">
        <short>The scroll Position, zero if not Visible</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.ScrollPos.Result">
        <short>The scroll Position, zero if not Visible</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.GetOtherScrollBar">
        <short>Get the ScrollBar of the opposite direction (horz/vert)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TControlScrollBar.GetOtherScrollBar.Result">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.ClientSize">
        <short>
          The currently remaining extent of the Parent Control, depending on ScrollBar visibility
        </short>
        <descr>return for vertical scrollbar the clientwidth</descr>
        <seealso>
        </seealso>
      </element>
      <element name="TControlScrollBar.ClientSize.Result">
        <short>for vertical scrollbar the clientwidth</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.ClientSizeWithBar">
        <short>The remaining extent of the Parent Control, when the ScrollBar is visible</short>
        <descr>
          Return for vertical scrollbar the clientwidth with the bar, even if Visible=false.
        </descr>
        <seealso></seealso>
      </element>
      <element name="TControlScrollBar.ClientSizeWithBar.Result">
        <short>
          For vertical scrollbar the clientwidth with the bar, even if Visible=false
        </short>
      </element>
      <!-- function Visibility: public -->
      <element name="TControlScrollBar.ClientSizeWithoutBar">
        <short>The remaining extent of the Parent Control, when the ScrollBar is not visible.
        </short>
        <descr>
          Return for vertical scrollbar the clientwidth without the bar, even if Visible=true.
        </descr>
        <seealso></seealso>
      </element>
      <element name="TControlScrollBar.ClientSizeWithoutBar.Result">
        <short>
          For vertical scrollbar the clientwidth without the bar, even if Visible=true
        </short>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Increment">
        <short>The small Position increment, applicable to the scrollbar arrows</short>
        <descr>
          The amount by which the Position moves if the triangle at either end of the bar is selected. The default value is 8 (pixels).
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlScrollBar.Kind">
        <short>The orientation for the scroll bar: horizontal or vertical</short>
        <descr></descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Page">
        <short>
          The slider size, position increment applicable to the scrollbar area beneath the slider
        </short>
        <descr>
          <p>
            The amount by which the scroll indicator moves if the cursor selects the scroll bar above, below or on either side of the scroll indicator. The default value is 80 (pixels).
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Position">
        <short>Position of the slider, 0..Range-Page</short>
        <descr>
          <p>
            The Position reflects the top coordinate of the slider, which is Range-Page when the slider is at the bottom of the bar.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Smooth">
        <short>Enables smooth scrolling, with automatic adjustment of Increment and Page.
        </short>
        <descr>
          Smooth scrolling uses an Increment of 10%, and a Page size of 90% of the visible client area.
        </descr>
        <seealso>
          <link id="TControlScrollBar.Increment"/>
          <link id="TControlScrollBar.Page"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TControlScrollBar.SmoothIsStored" link="TControlScrollBar.Smooth"/>
      <element name="TControlScrollBar.SmoothIsStored.Result">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Range">
        <short>The virtual size of the Parent Control</short>
        <descr>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TControlScrollBar.Size">
        <short>The adjustable size of the scroll bar</short>
        <descr>
          <p>
            The length of the bar is the Width (or Height) of the Parent Control, the Size is the other (free) coordinate.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Tracking">
        <short>Gives feedback while the slider is dragged</short>
        <descr>
          <p>
            When it takes an significant amount of time, to repaint the parent control at a new position, Tracking should be False to prevent flicker; then the control is updated only when the slider is released.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: published -->
      <element name="TControlScrollBar.Visible">
        <short>Definitely hides the scrollbar when False (default True)</short>
        <descr>
          <p>
            The scrollbar widget is visible only if (Visible=True) <b>and</b> (Range&gt;Page).
          </p>
          <p>
            Set Visible to False to disallow the user to scroll the content, while the content still can be scrolled by code.
          </p>
          <p>
            Use IsScrollBarVisible to get the current visible state of the widget.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar.IsScrollBarVisible"/>
        </seealso>
      </element>
<!-- object Visibility: default -->
      <element name="TScrollingWinControl">
        <short>Class of a windowed control with incorporated scroll bars</short>
        <descr>
          <p>
            This class introduces a logical (virtual) client area, part of which is visible in the physical (visible) client area. <link id="TControlScrollBar">ScrollBars</link> allow the user to scroll through the logical client area.
          </p>
        </descr>
        <seealso>
          <link id="TControlScrollBar"/>
          <link id="TForm"/>
          <link id="TScrollBox"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TScrollingWinControl.FHorzScrollBar" link="TScrollingWinControl.HorzScrollBar"/>
      <element name="TScrollingWinControl.FVertScrollBar" link="TScrollingWinControl.VertScrollBar"/>
      <element name="TScrollingWinControl.FAutoScroll" link="TScrollingWinControl.AutoScroll"/>
      <!-- variable Visibility: private -->
      <element name="TScrollingWinControl.FIsUpdating">
        <short>Prevents recursive updates, True while an update is already in progress</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScrollingWinControl.SetHorzScrollBar" link="TScrollingWinControl.HorzScrollBar"/>
      <element name="TScrollingWinControl.SetHorzScrollBar.Value">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScrollingWinControl.SetVertScrollBar" link="TScrollingWinControl.VertScrollBar"/>
      <element name="TScrollingWinControl.SetVertScrollBar.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.AlignControls" link="#LCL.Controls.TWinControl.AlignControls">
        <short>Also calculates sizes for the scrollbars if required</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.AlignControls">TWinControl.AlignControls</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.AlignControls.AControl">
        <short/>
      </element>
      <element name="TScrollingWinControl.AlignControls.ARect">
        <short/>
      </element>
      <element name="TScrollingWinControl.AutoScrollEnabled">
        <short>Indicates if automatic scrolling is enabled for the control</short>
        <descr>
          <p>
            <var>AutoScrollEnabled</var> is a <var>Boolean</var> function which indicates if automatic scrolling is enabled for the control. The return value is <b>True</b> when the control is <b>NOT</b> automatically resized, or used as a docksite by an active docking manager.
          </p>
          <p>
            Use the <var>AutoSize</var> property to enabled or disable automatic control resizing. Set the <var>UseDockManager</var> property to <b>False</b> to disable use of the <var>DockSite</var> for the control.
          </p>
        </descr>
        <seealso>
          <link id="TScrollBox.AutoSize"/>
          <link id="TScrollBox.DockSite"/>
          <link id="TWinControl.UseDockManager"/>
        </seealso>
      </element>
      <element name="TScrollingWinControl.AutoScrollEnabled.Result">
        <short>True when not automatically resized or used as a dock site</short>
      </element>
      <element name="TScrollingWinControl.CalculateAutoRanges">
        <short>Sets or resets the ranges used for scrollbars in the control</short>
        <descr>Used in the implementation of the ComputeScrollbars method.</descr>
        <seealso>
          <link id="TScrollingWinControl.ComputeScrollbars"/>
          <link id="TScrollingWinControl.HorzScrollBar"/>
          <link id="TScrollingWinControl.VertScrollBar"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.CreateWnd" link="#lcl.Controls.TWinControl.CreateWnd"/>
      <!-- function Visibility: protected -->
      <element name="TScrollingWinControl.GetClientScrollOffset">
        <short>The virtual origin of the physical client area</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TControl.GetClientScrollOffset">TControl.GetClientScrollOffset</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.GetClientScrollOffset.Result">
        <short>The ScrollBar Positions, or (0,0) if no scrollbars in use</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScrollingWinControl.GetLogicalClientRect" link="#LCL.Controls.TControl.GetLogicalClientRect">
        <short>Returns the full virtual ClientRect.
        </short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TControl.GetLogicalClientRect">TControl.GetLogicalClientRect</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.GetLogicalClientRect.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.DoOnResize" link="#LCL.Controls.TControl.DoOnResize">
        <short>Also updates scrollbars if needed</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TControl.DoOnResize">TControl.DoOnResize</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.GetPreferredSizeClientFrame">
        <short>
          Calculates the size of the client area for the control excluding visible scroll bars
        </short>
        <descr></descr>
        <seealso>
          <link id="TScrollingWinControl.AutoScroll"/>
          <link id="TScrollingWinControl.VertScrollBar"/>
          <link id="TScrollingWinControl.HorzScrollBar"/>
          <link id="TScrollingWinControl.Width"/>
          <link id="TScrollingWinControl.Height"/>
          <link id="TScrollingWinControl.ClientWidth"/>
          <link id="TScrollingWinControl.ClientHeight"/>
        </seealso>
      </element>
      <element name="TScrollingWinControl.GetPreferredSizeClientFrame.aWidth">
        <short>Width of the client area</short>
      </element>
      <element name="TScrollingWinControl.GetPreferredSizeClientFrame.aHeight">
        <short>Height of the client area</short>
      </element>
      <element name="TScrollingWinControl.WMSize">
        <short>Performs actions needed to handle WMSize messages</short>
        <descr>
          <p>
            <var>WMSize</var> is a procedure used to perform actions needed to handle WMSize messages for the control. WMSize calls the inherited WMSize method to set the bounds for the control, optionally using the bounds from the parent control.
          </p>
          <p>
            WMSize provides support for setting the window state based on size messages that originate in the LCL interface, and calls <var>Resizing</var> to realize the new window state.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.WMSize"/>
          <link id="TControl.WMSize"/>
          <link id="TScrollingWinControl.Resizing"/>
          <link id="TWindowState"/>
        </seealso>
      </element>
      <element name="TScrollingWinControl.WMSize.Message">
        <short>Message examined in the method</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.WMHScroll">
        <short>Delegates scroll messages to the horizontal ScrollBar</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScrollingWinControl.WMHScroll.Message">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.WMVScroll">
        <short>Delegates scroll messages to the vertical ScrollBar</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScrollingWinControl.WMVScroll.Message">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScrollingWinControl.ComputeScrollbars">
        <short>Updates Page, AutoRange, IsScrollBarVisible, returns True on changes</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TScrollingWinControl.ComputeScrollbars.Result">
        <short>True when something has changed</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScrollingWinControl.SetAutoScroll" link="TScrollingWinControl.AutoScroll"/>
      <element name="TScrollingWinControl.SetAutoScroll.Value">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.Loaded">
        <short>Also initializes the scroll bars</short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.Loaded">TWinControl.Loaded</link>
        </seealso>
      </element>
      <element name="TScrollingWinControl.Resizing">
        <short>
          Performs actions needed when the control processes the WMSize message
        </short>
        <descr>
          <p>
            Resizing is an empty implementation in TScrollingWinControl. It must be implemented in descendent form or control classes.
          </p>
        </descr>
        <seealso></seealso>
      </element>
      <element name="TScrollingWinControl.Resizing.State">
        <short/>
      </element>
      <!-- property Visibility: published -->
      <element name="TScrollingWinControl.AutoScroll">
        <short>Allows ScrollBars to be displayed only when needed (when True)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.SetAutoSize" link="#lcl.Controls.TControl.AutoSize"/>
      <element name="TScrollingWinControl.SetAutoSize.Value">
        <short>New value for the property</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TScrollingWinControl.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TScrollingWinControl.Create.TheOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TScrollingWinControl.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance. Destroy frees resources allocated for the <var>HorzScrollBar</var> and <var>VertScrollBar</var> properties. Destroy calls the inherited destructor prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TScrollingWinControl.HorzScrollBar"/>
          <link id="TScrollingWinControl.VertScrollBar"/>
        </seealso>
      </element>
      <element name="TScrollingWinControl.ScreenToClient" link="#LCL.Controls.TControl.ScreenToClient"/>
      <element name="TScrollingWinControl.ScreenToClient.Result">
        <short/>
      </element>
      <element name="TScrollingWinControl.ScreenToClient.APoint">
        <short/>
      </element>
      <element name="TScrollingWinControl.ClientToScreen" link="#LCL.Controls.TControl.ClientToScreen"/>
      <element name="TScrollingWinControl.ClientToScreen.Result">
        <short/>
      </element>
      <element name="TScrollingWinControl.ClientToScreen.APoint">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScrollingWinControl.UpdateScrollbars">
        <short>Initializes or updates the ScrollBars for the control</short>
        <descr>Ignores recursive calls.</descr>
        <seealso/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScrollingWinControl.GetControlClassDefaultSize" link="#LCL.Controls.TControl.GetControlClassDefaultSize"/>
      <element name="TScrollingWinControl.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TScrollingWinControl.ScrollBy">
        <short>Tells the widget to scroll the client area relative</short>
        <descr>The still visible part doesn't deserve a repaint (optimization).</descr>
        <seealso/>
      </element>
      <element name="TScrollingWinControl.ScrollBy.DeltaX">
        <short/>
      </element>
      <element name="TScrollingWinControl.ScrollBy.DeltaY">
        <short/>
      </element>
      <element name="TScrollingWinControl.ScrollInView">
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TScrollingWinControl.ScrollInView.AControl">
        <short>Control which provides the bounds adjusted in the method</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TScrollingWinControl.HorzScrollBar">
        <short>The horizontal scroll bar (LCL control)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: published -->
      <element name="TScrollingWinControl.VertScrollBar">
        <short>The vertical scroll bar (LCL control)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TScrollBox">
        <short>Implements a windowed control with scroll bars</short>
        <descr>
          <p>
            <var>TScrollBox</var> is a <var>TScrollingWinControl</var> descendant that implements a windowed control with scroll bars. TScrollBox sets the visibility for properties inherited from the ancestor class. TScrollBox includes an overridden constructor which sets the default values for properties in the class instance.
          </p>
        </descr>
        <seealso>
          <link id="TScrollingWinControl"/>
        </seealso>
      </element>
      <element name="TScrollBox.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <!-- constructor Visibility: public -->
      <element name="TScrollBox.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TScrollBox.Create.AOwner">
        <short>Owner for the class instance</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TScrollBox.Align" link="#LCL.Controls.TControl.Align"/>
      <element name="TScrollBox.Anchors" link="#LCL.Controls.TControl.Anchors"/>
      <element name="TScrollBox.AutoSize" link="#LCL.Controls.TControl.AutoSize"/>
      <element name="TScrollBox.AutoScroll" link="#LCL.Forms.TScrollingWinControl.AutoScroll"/>
      <element name="TScrollBox.BorderSpacing" link="#LCL.Controls.TControl.BorderSpacing"/>
      <element name="TScrollBox.BiDiMode" link="#LCL.Controls.TControl.BiDiMode"/>
      <element name="TScrollBox.BorderStyle" link="#LCL.Controls.TWinControl.BorderStyle"/>
      <element name="TScrollBox.ChildSizing" link="#LCL.Controls.TWinControl.ChildSizing"/>
      <element name="TScrollBox.ClientHeight" link="#LCL.Controls.TControl.ClientHeight"/>
      <element name="TScrollBox.ClientWidth" link="#LCL.Controls.TControl.ClientWidth"/>
      <element name="TScrollBox.Constraints" link="#LCL.Controls.TControl.Constraints"/>
      <element name="TScrollBox.DockSite" link="#LCL.Controls.TWinControl.DockSite"/>
      <element name="TScrollBox.DragCursor" link="#LCL.Controls.TControl.DragCursor"/>
      <element name="TScrollBox.DragKind" link="#LCL.Controls.TControl.DragKind"/>
      <element name="TScrollBox.DragMode" link="#LCL.Controls.TControl.DragMode"/>
      <element name="TScrollBox.Enabled" link="#LCL.Controls.TControl.Enabled"/>
      <element name="TScrollBox.Color" link="#LCL.Controls.TControl.Color"/>
      <element name="TScrollBox.Font" link="#LCL.Controls.TControl.Font"/>
      <element name="TScrollBox.ParentBackground" link="#LCL.Controls.TControl.ParentBackground"/>
      <element name="TScrollBox.ParentBiDiMode" link="#LCL.Controls.TControl.ParentBiDiMode"/>
      <element name="TScrollBox.ParentColor" link="#LCL.Controls.TControl.ParentColor"/>
      <element name="TScrollBox.ParentFont" link="#LCL.Controls.TControl.ParentFont"/>
      <element name="TScrollBox.ParentShowHint" link="#LCL.Controls.TControl.ParentShowHint"/>
      <element name="TScrollBox.PopupMenu" link="#LCL.Controls.TControl.PopupMenu"/>
      <element name="TScrollBox.ShowHint" link="#LCL.Controls.TControl.ShowHint"/>
      <element name="TScrollBox.TabOrder" link="#LCL.Controls.TWinControl.TabOrder"/>
      <element name="TScrollBox.TabStop" link="#LCL.Controls.TWinControl.TabStop"/>
      <element name="TScrollBox.Visible" link="#LCL.Controls.TControl.Visible"/>
      <element name="TScrollBox.OnClick" link="#LCL.Controls.TControl.OnClick"/>
      <element name="TScrollBox.OnConstrainedResize" link="#LCL.Controls.TControl.OnConstrainedResize"/>
      <element name="TScrollBox.OnDblClick" link="#LCL.Controls.TControl.OnDblClick"/>
      <element name="TScrollBox.OnDockDrop" link="#LCL.Controls.TWinControl.OnDockDrop"/>
      <element name="TScrollBox.OnDockOver" link="#LCL.Controls.TWinControl.OnDockOver"/>
      <element name="TScrollBox.OnDragDrop" link="#LCL.Controls.TControl.OnDragDrop"/>
      <element name="TScrollBox.OnDragOver" link="#LCL.Controls.TControl.OnDragOver"/>
      <element name="TScrollBox.OnEndDock" link="#LCL.Controls.TControl.OnEndDock"/>
      <element name="TScrollBox.OnEndDrag" link="#LCL.Controls.TControl.OnEndDrag"/>
      <element name="TScrollBox.OnEnter" link="#LCL.Controls.TWinControl.OnEnter"/>
      <element name="TScrollBox.OnExit" link="#LCL.Controls.TWinControl.OnExit"/>
      <element name="TScrollBox.OnGetSiteInfo" link="#LCL.Controls.TWinControl.OnGetSiteInfo"/>
      <element name="TScrollBox.OnMouseDown" link="#LCL.Controls.TControl.OnMouseDown"/>
      <element name="TScrollBox.OnMouseEnter" link="#LCL.Controls.TControl.OnMouseEnter"/>
      <element name="TScrollBox.OnMouseLeave" link="#LCL.Controls.TControl.OnMouseLeave"/>
      <element name="TScrollBox.OnMouseMove" link="#LCL.Controls.TControl.OnMouseMove"/>
      <element name="TScrollBox.OnMouseUp" link="#LCL.Controls.TControl.OnMouseUp"/>
      <element name="TScrollBox.OnMouseWheel" link="#LCL.Controls.TControl.OnMouseWheel"/>
      <element name="TScrollBox.OnMouseWheelDown" link="#LCL.Controls.TControl.OnMouseWheelDown"/>
      <element name="TScrollBox.OnMouseWheelUp" link="#LCL.Controls.TControl.OnMouseWheelUp"/>
      <element name="TScrollBox.OnMouseWheelHorz" link="#LCL.Controls.TControl.OnMouseWheelHorz"/>
      <element name="TScrollBox.OnMouseWheelLeft" link="#LCL.Controls.TControl.OnMouseWheelLeft"/>
      <element name="TScrollBox.OnMouseWheelRight" link="#LCL.Controls.TControl.OnMouseWheelRight"/>
      <element name="TScrollBox.OnResize" link="#LCL.Controls.TControl.OnResize"/>
      <element name="TScrollBox.OnStartDock" link="#LCL.Controls.TControl.OnStartDock"/>
      <element name="TScrollBox.OnStartDrag" link="#LCL.Controls.TControl.OnStartDrag"/>
      <element name="TScrollBox.OnUnDock" link="#LCL.Controls.TWinControl.OnUnDock"/>
      <element name="TScrollBox.OnPaint" link="#LCL.Controls.TCustomControl.OnPaint"/>
      <element name="TCustomDesignControl">
        <short>Provides a designer surface for scaling and layout of its child controls</short>
        <descr>
          <p>
            <var>TCustomDesignControl</var> is a <var>TScrollingWinControl</var> descendant which provides a designer surface used for scaling and layout of its child controls.
          </p>
          <p>
            Properties are provided to set the display density (Pixels Per Inch) for design-time and run-time usage, and to Scale child controls. Methods are also provided to use <var>TLayoutAdjustmentPolicy</var> to layout and to re-size the child controls.
          </p>
          <p>
            An overridden <var>Loaded</var> method is provided to adjust the design-time PPI (when scaling is enabled in the application).
          </p>
          <p>
            TCustomDesignControl is used as the ancestor for <var>TCustomFrame</var> and <var>TCustomForm</var>, and is the type used for the <var>ParentForm</var> property in <var>TControl</var> and its descendants.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.Scaled"/>
          <link id="TCustomForm"/>
          <link id="TCustomFrame"/>
          <link id="TControl.ParentForm"/>
          <link id="GetParentDesignControl"/>
          <link id="NeedParentDesignControl"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.FScaled"/>
      <element name="TCustomDesignControl.FDesignTimePPI"/>
      <element name="TCustomDesignControl.FPixelsPerInch"/>
      <element name="TCustomDesignControl.DesignTimePPIIsStored">
        <!-- TODO -->
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomDesignControl.DesignTimePPIIsStored.Result">
        <short></short>
      </element>
      <element name="TCustomDesignControl.SetDesignTimePPI">
        <short>Sets the value for the DesignTimePPI property</short>
        <descr/>
        <seealso>
          <link id="TCustomDesignControl.DesignTimePPI"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.SetDesignTimePPI.ADesignTimePPI">
        <short>New value for the property</short>
      </element>
      <element name="TCustomDesignControl.SetScaled">
        <short>Sets the value for the Scaled property</short>
        <descr/>
        <seealso>
          <link id="TCustomDesignControl.Scaled"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.SetScaled.AScaled">
        <short>New value for the property</short>
      </element>
      <element name="TCustomDesignControl.DoAutoAdjustLayout">
        <short>
          Applies size and layout changes to the design surface and its Parent control
        </short>
        <descr>
          <p>
            <var>DoAutoAdjustLayout</var> is a procedure used to perform actions needed to apply size and layout changes to the design surface and its <var>Parent</var> control.
          </p>
          <p>
            <var>DoAutoAdjustLayout</var> adjusts the height and width for the design surface by the specified scaling factors. Similarly, the <var>BorderSpacing</var> and <var>Constraints</var> in the control are adjusted using the scaling factors. Finally, the <var>SetBounds</var> method is called to apply the new values for Height and Width to the design surface.
          </p>
          <remark>
            Please note: No actions are performed in the method when the Parent property has not been assigned (contains <b>Nil</b>). In addition, no actions are performed when <var>AMode</var> omits the <var>lapAutoAdjustWithoutHorizontalScrolling</var> and <var>lapAutoAdjustForDPI</var>  enumeration values.
          </remark>
        </descr>
        <seealso>
          <link id="TCustomDesignControl.Parent"/>
          <link id="TCustomDesignControl.BorderSpacing"/>
          <link id="TCustomDesignControl.Constraints"/>
          <link id="TLayoutAdjustmentPolicy.lapAutoAdjustWithoutHorizontalScrolling"/>
          <link id="TLayoutAdjustmentPolicy.lapAutoAdjustForDPI"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.DoAutoAdjustLayout.AMode">
        <short>TLayoutAdjustmentPolicy applied in the method</short>
      </element>
      <element name="TCustomDesignControl.DoAutoAdjustLayout.AXProportion">
        <short>Horizontal scaling factor applied in the method</short>
      </element>
      <element name="TCustomDesignControl.DoAutoAdjustLayout.AYProportion">
        <short>Vertical scaling factor applied in the method</short>
      </element>
      <element name="TCustomDesignControl.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for the class instance. Create calls the inherited method using the value in <var>TheOwner</var> as the the owner of the class instance. Create sets the default values for the following properties:
          </p>
          <ul>
            <li>Scaled</li>
            <li>DesignTimePPI</li>
            <li>PixelsPerInch</li>
          </ul>
          <p>
            When scaling is enabled in the Application, the value in <var>DesignTimePPI</var> is used as the <var>PixelsPerInch</var> setting in the <var>Font</var> property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomDesignControl.Scaled"/>
          <link id="TCustomDesignControl.PixelsPerInch"/>
          <link id="TCustomDesignControl.Scaled"/>
          <link id="TCustomDesignControl.Font"/>
          <link id="TApplication.Scaled"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.Create.TheOwner">
        <short>Owner of the class instance</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout">
        <short>
          Applies a new display density (Pixels Per Inch) for a layout policy to the control
        </short>
        <descr>
          <p>
            <var>AutoAdjustLayout</var> is used to set the value in the <var>PixelsPerInch</var> property to the value specified in <var>AToPPI</var> for the <var>lapAutoAdjustForDPI</var> layout policy. AutoAdjustLayout calls the inherited method.
          </p>
          <remark>
            No additional actions are performed in the method when <var>AMode</var> contains a value other than <var>lapAutoAdjustForDPI</var>.
          </remark>
        </descr>
        <seealso>
          <link id="TCustomDesignControl.PixelsPerInch"/>
          <link id="TCustomDesignControl.DoAutoAdjustLayout"/>
          <link id="TLayoutAdjustmentPolicy"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.AMode">
        <short>Layout policy to use for the design surface</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.AFromPPI">
        <short>Original display density setting</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.AToPPI">
        <short>New display density setting</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.AOldFormWidth">
        <short>Original form width</short>
      </element>
      <element name="TCustomDesignControl.AutoAdjustLayout.ANewFormWidth">
        <short>New form width</short>
      </element>
      <element name="TCustomDesignControl.DesignTimePPI">
        <short>Design-time Pixels Per Inch for the designer surface</short>
        <descr>
          <p>
            <var>DesignTimePPI</var> is an <var>Integer</var> property that contains the display density (or Pixels Per Inch) used on the designer surface. The default value for the property is <b>96</b> (pixels).
          </p>
          <p>
            The property value is normally set when the component is loaded using the LCL streaming mechanism. It can be assigned at design-time to the value in <var>ADesignTimePPI</var> only when the new value matches the display density for the current Screen where the designer surface is used. The value can be changed at run-time, but the programmer must ensure that the value is valid for the intended usage.
          </p>
          <p>
            An <var>EInvalidOperation</var> exception is raised if an invalid value is specified at design-time.
          </p>
          <p>
            When scaling is enabled in the Application, the value in DesignTimePPI is assigned to the <var>Font</var> for the designer surface.
          </p>
          <p>
            Use <var>PixelsPerInch</var> to access the run-time display density for the designer surface.
          </p>
        </descr>
        <seealso>
          <link id="TCustomDesignControl.PixelsPerInch"/>
          <link id="TCustomDesignControl.Font"/>
          <link id="TCustomDesignControl.Scaled"/>
          <link id="TApplication.Scaled"/>
        </seealso>
      </element>
      <element name="TCustomDesignControl.PixelsPerInch">
        <short>Run-time Pixels Per Inch for the designer surface</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomDesignControl.Scaled">
        <short>
          Indicates if the design surface is scaled to reflect changes in display density (Pixels Per Inch)
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomFrame">
        <short>The base type for <var>TFrame</var></short>
        <descr>
          <p>
            <var>TCustomFrame</var> is a <var>TCustomDesignControl</var> descendant which implements the base class for <var>TFrame</var>.  A Frame is a named container for related components. Groups of  controls can be place on a frame, and re-used in your applications.
          </p>
          <p>
            A Frame has behavior very similar to a Form. Their unique ability is that they can be embedded into forms or other frames in the designer.  Like forms, they are stored in two separate files: the code is stored in a .pas unit file, and the design is stored in a .lfm file.
          </p>
          <p>
            Frames can be created and designed in the Lazarus IDE by creating a new Frame module, and using the unit in your application. An existing frame can be added using the TFrame component on the Standard tab in the Lazarus IDE; you will be prompted for the TFrame class to use for the component.
          </p>
          <p>
            Frames can also be created entirely in code at run-time. They do not have to be installed in the Lazarus IDE. One drawback is that complex inheritance hierarchies for <var>TFrame</var> classes can be problematic; they do not propagate changes to all derived frames in a multi-level inheritance tree.
          </p>
        </descr>
        <seealso>
          <link id="TFrame"/>
          <link id="TCustomDesignControl"/>
        </seealso>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.AddActionList">
        <short>Adds the specified list of Actions to the Parent form for the frame class</short>
        <descr>
          <remark>
            Please note: No actions are performed in the method when a Parent form has not been assigned for the class instance.
          </remark>
        </descr>
        <seealso>
          <link id="GetParentForm"/>
        </seealso>
      </element>
      <element name="TCustomFrame.AddActionList.ActionList">
        <short>List of Actions added in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.RemoveActionList">
        <short>Removes the specified list of Actions from the Parent form</short>
        <descr>
          <remark>
            Please note: No actions are performed in the method when a Parent form has not been assigned for the class instance.
          </remark>
        </descr>
        <seealso>
          <link id="GetParentForm"/>
        </seealso>
      </element>
      <element name="TCustomFrame.RemoveActionList.ActionList">
        <short>List of Actions removed in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.ReadDesignLeft">
        <short>Implements reading the Left property for the designer surface</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomFrame.ReadDesignLeft.Reader">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.ReadDesignTop">
        <short>Implements reading the Right property for the designer surface</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomFrame.ReadDesignTop.Reader">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.WriteDesignLeft">
        <short>Implements writing the Left property for the designer surface</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomFrame.WriteDesignLeft.Writer">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TCustomFrame.WriteDesignTop">
        <short>Implements writing the Top property for the designer surface</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomFrame.WriteDesignTop.Writer">
        <short/>
      </element>
      <element name="TCustomFrame.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="TCustomFrame.GetChildren">
        <short>
          Invokes Proc for all Controls and also for all Components without a Parent
        </short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TComponent.GetChildren">TComponent.GetChildren</link>
          <link id="#LCL.Controls.TWinControl.GetChildren">TWinControl.GetChildren</link>
        </seealso>
      </element>
      <element name="TCustomFrame.GetChildren.Proc">
        <short>The callback method</short>
      </element>
      <element name="TCustomFrame.GetChildren.Root">
        <short>Components are enumerated only if Root=Self</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomFrame.Notification">
        <short>Also handles add/remove of ActionLists</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TComponent.Notification">TComponent.Notification</link>
          <link id="#LCL.Controls.TControl.Notification">TControl.Notification</link>
        </seealso>
      </element>
      <element name="TCustomFrame.Notification.AComponent">
        <short>Component for the notification</short>
      </element>
      <element name="TCustomFrame.Notification.Operation">
        <short>Operation for the notification</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomFrame.SetParent">
        <short>Sets the value for the Parent property</short>
        <descr>
          Also updates the ActionLists, and performs automatic layout adjustments when needed.
        </descr>
        <seealso>
          <link id="#LCL.Controls.TControl.SetParent"/>
          <link id="#LCL.Controls.TControl.Parent"/>
        </seealso>
      </element>
      <element name="TCustomFrame.SetParent.AParent">
        <short>Value assigned to the Parent property</short>
      </element>
      <element name="TCustomFrame.DefineProperties" link="#rtl.Classes.TComponent.DefineProperties"/>
      <element name="TCustomFrame.DefineProperties.Filer">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomFrame.CalculatePreferredSize" link="#LCL.Controls.TControl.CalculatePreferredSize"/>
      <element name="TCustomFrame.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TCustomFrame.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TCustomFrame.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCustomFrame.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            Create is the overridden constructor for the class instance. Create calls the inherited method using AOwner as the owner for the class instance. Create sets the ControlStyle property to the following enumeration values:
          </p>
          <ul>
            <li>csAcceptsControls</li>
            <li>csCaptureMouse</li>
            <li>csClickEvents</li>
            <li>csSetCaption</li>
            <li>csDoubleClicks</li>
            <li>csParentBackground</li>
          </ul>
          <p>
            Create uses the default size for its class type to set the initial bounds for the control.
          </p>
        </descr>
        <errors>
          Raises an EResNotFound exception at run-time if the ClassType for the class instance
          is not derived from TFrame.
        </errors>
        <seealso>
          <link id="#rtl.Classes.TComponent.Create"/>
        </seealso>
      </element>
      <element name="TCustomFrame.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TCustomFrame.GetControlClassDefaultSize" link="#LCL.Controls.TControl.GetControlClassDefaultSize"/>
      <element name="TCustomFrame.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TCustomFrameClass" link="TCustomFrame"/>
      <!-- object Visibility: default -->
      <element name="TFrame">
        <short>
          Frames can be designed like Forms and used like custom controls, without much coding or installation in the IDE.
        </short>
        <descr>
          <p>
            <var>TFrame</var> is a <var>TCustomFrame</var> descendant which implements a named container for related components. Groups of  controls can be place on a frame, and re-used in your applications.
          </p>
          <p>
            A Frame has behavior very similar to a Form. Their unique ability is that they can be embedded into forms or other frames in the designer.  Like forms, they are stored in two separate files: the code is stored in a .pas unit file, and the design is stored in a .lfm file.
          </p>
          <p>
            Frames can be created and designed in the Lazarus IDE by creating a new Frame module, and using the unit in your application. An existing frame can be added using the TFrame component on the Standard tab in the Lazarus IDE; you will be prompted for the TFrame class to use for the component.
          </p>
          <p>
            Frames can also be created entirely in code at run-time. They do not have to be installed in the Lazarus IDE. One drawback is that complex inheritance hierarchies for <var>TFrame</var> classes can be problematic; they do not propagate changes to all derived frames in the entire inheritance tree.
          </p>
          <p>
            TFrame contains a new property which indicates the LCL (Lazarus Component Library) version number used in the container. An overridden constructor is also introduced to initialize the value in the LCLVersion property. TFrame sets the visibility for properties defines in ancestor classes.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="TFrame.FLCLVersion" link="TFrame.LCLVersion"/>
      <element name="TFrame.LCLVersionIsStored" link="TFrame.LCLVersion"/>
      <element name="TFrame.LCLVersionIsStored.Result">
        <short/>
      </element>
      <element name="TFrame.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TFrame.Create.TheOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- property Visibility: published -->
      <element name="TFrame.Align" link="#LCL.Controls.TControl.Align"/>
      <element name="TFrame.Anchors" link="#LCL.Controls.TControl.Anchors"/>
      <element name="TFrame.AutoScroll" link="#LCL.Forms.TScrollingWinControl.AutoScroll"/>
      <element name="TFrame.AutoSize" link="#LCL.Controls.TControl.AutoSize"/>
      <element name="TFrame.BiDiMode" link="#LCL.Controls.TControl.BiDiMode"/>
      <element name="TFrame.BorderSpacing" link="#LCL.Controls.TControl.BorderSpacing"/>
      <element name="TFrame.ChildSizing" link="#LCL.Controls.TWinControl.ChildSizing"/>
      <element name="TFrame.ClientHeight" link="#LCL.Controls.TControl.ClientHeight"/>
      <element name="TFrame.ClientWidth" link="#LCL.Controls.TControl.ClientWidth"/>
      <element name="TFrame.Color" link="#LCL.Controls.TControl.Color"/>
      <element name="TFrame.Constraints" link="#LCL.Controls.TControl.Constraints"/>
      <element name="TFrame.DockSite" link="#LCL.Controls.TWinControl.DockSite"/>
      <element name="TFrame.DragCursor" link="#LCL.Controls.TControl.DragCursor"/>
      <element name="TFrame.DragKind" link="#LCL.Controls.TControl.DragKind"/>
      <element name="TFrame.DragMode" link="#LCL.Controls.TControl.DragMode"/>
      <element name="TFrame.Enabled" link="#LCL.Controls.TControl.Enabled"/>
      <element name="TFrame.Font" link="#LCL.Controls.TControl.Font"/>
      <element name="TFrame.LCLVersion" link="#LCL.LCLVersion.lcl_version"/>
      <element name="TFrame.OnClick" link="#LCL.Controls.TControl.OnClick"/>
      <element name="TFrame.OnConstrainedResize" link="#LCL.Controls.TControl.OnConstrainedResize"/>
      <element name="TFrame.OnContextPopup" link="#LCL.Controls.TControl.OnContextPopup"/>
      <element name="TFrame.OnDblClick" link="#LCL.Controls.TControl.OnDblClick"/>
      <element name="TFrame.OnDockDrop" link="#LCL.Controls.TWinControl.OnDockDrop"/>
      <element name="TFrame.OnDockOver" link="#LCL.Controls.TWinControl.OnDockOver"/>
      <element name="TFrame.OnDragDrop" link="#LCL.Controls.TControl.OnDragDrop"/>
      <element name="TFrame.OnDragOver" link="#LCL.Controls.TControl.OnDragOver"/>
      <element name="TFrame.OnEndDock" link="#LCL.Controls.TControl.OnEndDock"/>
      <element name="TFrame.OnEndDrag" link="#LCL.Controls.TControl.OnEndDrag"/>
      <element name="TFrame.OnEnter" link="#LCL.Controls.TWinControl.OnEnter"/>
      <element name="TFrame.OnExit" link="#LCL.Controls.TWinControl.OnExit"/>
      <element name="TFrame.OnGetSiteInfo" link="#LCL.Controls.TWinControl.OnGetSiteInfo"/>
      <element name="TFrame.OnMouseDown" link="#LCL.Controls.TControl.OnMouseDown"/>
      <element name="TFrame.OnMouseEnter" link="#LCL.Controls.TControl.OnMouseEnter"/>
      <element name="TFrame.OnMouseLeave" link="#LCL.Controls.TControl.OnMouseLeave"/>
      <element name="TFrame.OnMouseMove" link="#LCL.Controls.TControl.OnMouseMove"/>
      <element name="TFrame.OnMouseUp" link="#LCL.Controls.TControl.OnMouseUp"/>
      <element name="TFrame.OnMouseWheel" link="#LCL.Controls.TControl.OnMouseWheel"/>
      <element name="TFrame.OnMouseWheelDown" link="#LCL.Controls.TControl.OnMouseWheelDown"/>
      <element name="TFrame.OnMouseWheelUp" link="#LCL.Controls.TControl.OnMouseWheelUp"/>
      <element name="TFrame.OnResize" link="#LCL.Controls.TControl.OnResize"/>
      <element name="TFrame.OnStartDock" link="#LCL.Controls.TControl.OnStartDock"/>
      <element name="TFrame.OnStartDrag" link="#LCL.Controls.TControl.OnStartDrag"/>
      <element name="TFrame.OnUnDock" link="#LCL.Controls.TWinControl.OnUnDock"/>
      <element name="TFrame.ParentBiDiMode" link="#LCL.Controls.TControl.ParentBiDiMode"/>
      <element name="TFrame.ParentColor" link="#LCL.Controls.TControl.ParentColor"/>
      <element name="TFrame.ParentFont" link="#LCL.Controls.TControl.ParentFont"/>
      <element name="TFrame.ParentShowHint" link="#LCL.Controls.TControl.ParentShowHint"/>
      <element name="TFrame.PopupMenu" link="#LCL.Controls.TControl.PopupMenu"/>
      <element name="TFrame.ShowHint" link="#LCL.Controls.TControl.ShowHint"/>
      <element name="TFrame.TabOrder" link="#LCL.Controls.TWinControl.TabOrder"/>
      <element name="TFrame.TabStop" link="#LCL.Controls.TWinControl.TabStop"/>
      <element name="TFrame.Visible" link="#LCL.Controls.TControl.Visible"/>
      <!-- enumeration type Visibility: default -->
      <element name="TBorderIcon">
        <short>
          Visual elements in window title bars; depends on window manager support.
        </short>
        <descr>
          <dl>
            <dt>biSystemMenu</dt>
            <dd>The form has a System menu (Maybe not all windowmanager supports this)</dd>
            <dt>biMinimize</dt>
            <dd>The form has an minimize button</dd>
            <dt>biMaximize</dt>
            <dd>The form has a maximize button</dd>
            <dt>biHelp</dt>
            <dd>When you click this button a Question Cursor appears, and the help routines are
              called if you click on an control</dd>
          </dl>
        </descr>
        <seealso/>
      </element>
      <element name="TBorderIcon.biSystemMenu">
        <short>Window has a system menu</short>
      </element>
      <element name="TBorderIcon.biMinimize">
        <short>Window has an Minimize button</short>
      </element>
      <element name="TBorderIcon.biMaximize">
        <short>Window has an Maximize button</short>
      </element>
      <element name="TBorderIcon.biHelp">
        <short>Window has an Help button</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TBorderIcons" link="TBorderIcon"/>
      <!-- enumeration type Visibility: default -->
      <element name="TDefaultMonitor">
        <short>The preferred monitor for showing a form</short>
        <descr>
          <p>
            When a form is not assigned to a specific monitor, assume the following display context:
          </p>
          <dl>
            <dt>dmDesktop</dt>
            <dd>No attempt to choose specific monitor</dd>
            <dt>dmPrimary</dt>
            <dd>On the primary monitor</dd>
            <dt>dmMainForm</dt>
            <dd>On the same monitor as the main form; if there is no main form then use
              dmPrimary behavior</dd>
            <dt>dmActiveForm</dt>
            <dd>On the same monitor as the currently active form; if there is no active form
              then use dmMainForm behavior</dd>
          </dl>
        </descr>
      </element>
      <element name="TDefaultMonitor.dmDesktop">
        <short>Place the form on the full desktop</short>
      </element>
      <element name="TDefaultMonitor.dmPrimary">
        <short>Place the form on the primary monitor</short>
      </element>
      <element name="TDefaultMonitor.dmMainForm">
        <short>
          Place the form on the same monitor as the main form. If there is no such form then use the primary monitor.
        </short>
      </element>
      <element name="TDefaultMonitor.dmActiveForm">
        <short>
          Place the form on the same monitor as the currently active form. If there is no such form then use the primary monitor.
        </short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TFormStateType">
        <short>Form state flags</short>
        <descr>
          <p>The form states are:</p>
          <dl>
            <dt>fsCreating</dt>
            <dd>initializing (form streaming)</dd>
            <dt>fsVisible</dt>
            <dd>form should be shown</dd>
            <dt>fsShowing</dt>
            <dd>form handling WM_SHOWWINDOW message</dd>
            <dt>fsModal</dt>
            <dd>form is modal</dd>
            <dt>fsCreatedMDIChild</dt>
            <dd>not yet implemented</dd>
            <dt>fsBorderStyleChanged</dt>
            <dd>border style changed before window handle creation</dd>
            <dt>fsFormStyleChanged</dt>
            <dd>form style is changed before window handle creation</dd>
            <dt>fsFirstShow</dt>
            <dd>form is shown for the first time</dd>
            <dt>fsDisableAutoSize</dt>
            <dd>disable autosize</dd>
          </dl>
        </descr>
        <seealso/>
      </element>
      <element name="TFormStateType.fsCreating">
        <short>initializing (form streaming)</short>
      </element>
      <element name="TFormStateType.fsVisible">
        <short>form should be shown</short>
      </element>
      <element name="TFormStateType.fsShowing">
        <short>form handling WM_SHOWWINDOW message</short>
      </element>
      <element name="TFormStateType.fsModal">
        <short>form is modal</short>
      </element>
      <element name="TFormStateType.fsCreatedMDIChild">
        <short>not yet implemented</short>
      </element>
      <element name="TFormStateType.fsBorderStyleChanged">
        <short>border style changed before window handle creation</short>
      </element>
      <element name="TFormStateType.fsFormStyleChanged">
        <short>form style is changed before window handle creation</short>
      </element>
      <element name="TFormStateType.fsFirstShow">
        <short>form is shown for the first time</short>
      </element>
      <element name="TFormStateType.fsDisableAutoSize">
        <short>disable autosize</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TFormState" link="TFormStateType">
        <short>The set of form state flags</short>
        <descr/>
        <seealso/>
      </element>
      <!-- range type Visibility: default -->
      <element name="TModalResult">
        <short>Dummy type for the values that can be returned as a modal result</short>
        <descr>
          <p>
            Even though the type is defined as an integer, only the defined constant values should be used (mrOK, mrCancel, et. al.).
          </p>
        </descr>
        <seealso>
          <link id="controls.mrNone"/>
          <link id="controls.mrOK"/>
          <link id="controls.mrCancel"/>
          <link id="controls.mrAbort"/>
          <link id="controls.mrRetry"/>
          <link id="controls.mrIgnore"/>
          <link id="controls.mrYes"/>
          <link id="controls.mrNo"/>
          <link id="controls.mrAll"/>
        </seealso>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PModalResult" link="TModalResult"/>
      <!-- enumeration type Visibility: default -->
      <element name="TFormHandlerType">
        <short>TForm Notification handler types</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormHandlerType.fhtFirstShow">
        <short>Notified on first form Show</short>
      </element>
      <element name="TFormHandlerType.fhtClose">
        <short>Notified on form Close</short>
      </element>
      <element name="TFormHandlerType.fhtCreate">
        <short>Notified after form Create</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TShowInTaskbar">
        <short>How a form is represented in the TaskBar</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TShowInTaskbar.stDefault">
        <short>
          Uses the default rules from the platform for showing the form in the TaskBar
        </short>
        <notes><note>platform?</note></notes>
      </element>
      <element name="TShowInTaskbar.stAlways">
        <short>Always show the form in the TaskBar</short>
      </element>
      <element name="TShowInTaskbar.stNever">
        <short>Never show the form in the TaskBar</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TPopupMode">
        <short>Defines the handling performed for a parent window in forms and dialogs</short>
        <descr>
          <p>
            <var>TPopupMode</var> is an enumerated type with values that specify how the parent is determined for a form or dialog. <var>TPopupMode</var> is the type used for the <var>PopupMode</var> property in <var>TCustomForm</var>.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.PopupMode"/>
          <link id="TCustomForm.PopupParent"/>
          <link id="TCustomForm.GetRealPopupParent"/>
          <link id="TCustomForm.SetPopupParent"/>
        </seealso>
      </element>
      <element name="TPopupMode.pmNone">
        <short>
          modal: popup to active form or if not available, to main form; non-modal: no window parent
        </short>
      <descr>
        <p>
          For modal windows, the handle has to be recreated in ShowModal. If this is not wanted, please use explicitly pmAuto before calling ShowModal.
        </p>
      </descr>
      </element>
      <element name="TPopupMode.pmAuto">
        <short>
          modal and non-modal: popup to active form or if not available, to main form
        </short>
      </element>
      <element name="TPopupMode.pmExplicit">
        <short>
          modal and non-modal: popup to PopupParent or if not available, to main form
        </short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TCloseEvent">
        <short>Type used for an OnClose event handler in a form</short>
        <descr>
          <p>Closing a form can have several meanings:</p>
          <dl>
            <dt>caNone</dt>
            <dd>Do nothing (don't close).</dd>
            <dt>caHide</dt>
            <dd>Hide the form (default for modal forms).</dd>
            <dt>caFree</dt>
            <dd>Destroy the form.</dd>
            <dt>caMinimize</dt>
            <dd>Minimize the form (MDI child default).</dd>
          </dl>
          <p>The handler can set CloseAction to the desired value for the action.</p>
        </descr>
        <seealso/>
      </element>
      <element name="TCloseEvent.Sender">
        <short>The form that received an Close request</short>
      </element>
      <element name="TCloseEvent.CloseAction">
        <short>Set this to caNone, to prevent the form from closing</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TCloseQueryEvent">
        <short>Type of an form OnCloseQuery handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCloseQueryEvent.Sender">
        <short>The form that received an Close request</short>
      </element>
      <element name="TCloseQueryEvent.CanClose">
        <short>Set to False to deny closing</short>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDropFilesEvent">
        <short>Type used for an OnDropFiles event handler</short>
        <descr>
          <p>
            <var>TDropFilesEvent</var> is an object procedure which specifies an event handler triggered when files are dropped on a drag and drop-enabled control.
          </p>
          <p>
            <var>TDropFilesEvent</var> is the type used to implement the <var>OnDropFiles</var> property in <var>TCustomForm</var> and <var>TApplication</var>. Applications must implement a procedure using the signature for the event handler, and assign it to the property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnDropFiles"/>
          <link id="TApplication.OnDropFiles"/>
          <link id="TApplicationProperties.OnDropFiles"/>
        </seealso>
      </element>
      <element name="TDropFilesEvent.Sender">
        <short>The control that received the dropped files</short>
      </element>
      <element name="TDropFilesEvent.FileNames">
        <short>The list of the dropped files</short>
      </element>
      <!-- function type Visibility: default -->
      <element name="THelpEvent">
        <short>Type used for an OnHelp event handler</short>
        <descr>
          <p>
            <var>THelpEvent</var> is an object function which specifies an event handler signalled when Help is requested in an application or form. <var>THelpEvent</var> is the type used to implement the <var>OnHelp</var> event handler in <var>TCustomForm</var> and <var>TApplication</var>. Applications must implement a function using the signature for the event handler, and assign it to the property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnHelp"/>
          <link id="TApplication.OnHelp"/>
          <link id="TApplicationProperties.OnHelp"/>
        </seealso>
      </element>
      <element name="THelpEvent.Result">
        <short>
          Indicates if the help request is satisfied by the event handler; False causes the default help handler for the application to be used
        </short>
      </element>
      <element name="THelpEvent.Command">
        <short>Help command type requested; either HELP_CONTEXT or HELP_COMMAND</short>
      </element>
      <element name="THelpEvent.Data">
        <short>Context data for the help request</short>
      </element>
      <element name="THelpEvent.CallHelp">
        <short>False suppresses help display</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TShortCutEvent">
        <short>Type used for an OnShortcut event handler</short>
        <descr>
          <p>
            A shortcut handler is invoked when a key is pressed, before any other processing. It can interpret the key as an shortcut and act accordingly. In this case, <var>Handled</var> should be set to <b>True</b> to prevent further processing of the key.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TShortCutEvent.Msg">
        <short>The key event message</short>
      </element>
      <element name="TShortCutEvent.Handled">
        <short>Set Handled to True to prevent further processing of the key</short>
      </element>
      <element name="TModalDialogFinished">
        <short>
          Specifies an event handler signalled when a modal message dialog is completed
        </short>
        <descr>
          <p>
            <var>TModalDialogFinished</var> is an object procedure which specifies an event handler signalled when a modal message dialog is completed. The <var>AResult</var> argument contains the modal result constant returned from the message dialog.
          </p>
          <p>
            <var>TModalDialogFinished</var> is the type used to implement the <var>TCustomForm.OnShowModalFinished</var> and <var>TApplication.OnMessageDialogFinished</var> properties.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnShowModalFinished"/>
          <link id="TApplication.OnMessageDialogFinished"/>
          <link id="#LCL.Controls.TModalResult"/>
        </seealso>
      </element>
      <element name="TModalDialogFinished.Sender">
        <short>TObject instance for the event notification</short>
      </element>
      <element name="TModalDialogFinished.AResult">
        <short>Modal result value from the dialog</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomForm">
        <short>The base type for <var>TForm</var> classes</short>
        <descr>
          <p>
            <var>TCustomForm</var> is a <var>TCustomDesignControl</var> descendant that implements the base type for <var>TForm</var> classes.
          </p>
          <p>
            Forms represent a window or a dialog used as the user interface for a GUI application. It is a container where visual components (such as buttons, labels, edit fields, images, etc.) can be placed. It is also a designer surface which provides design-time support for configuration and layout of the content placed on the form.
          </p>
          <p>
            <var>TCustomForm</var> acts an abstraction layer which masks implementation-specific routines required for the various widget sets supported in the Lazarus Component Library (<b>LCL</b>). Methods and properties are provided which interact with the underlying Operating System or platform, and provide a common API for form-related operations.
          </p>
        </descr>
        <seealso>
          <link id="TForm"/>
          <link id="TCustomDesignControl"/>
        </seealso>
      </element>
      <!-- variable Visibility: protected -->
      <element name="TCustomForm.FActive" link="TCustomForm.Active"/>
      <element name="TCustomForm.FActiveControl" link="TCustomForm.ActiveControl"/>
      <element name="TCustomForm.FActiveDefaultControl" link="TCustomForm.ActiveDefaultControl"/>
      <element name="TCustomForm.FAllowDropFiles" link="TCustomForm.AllowDropFiles"/>
      <element name="TCustomForm.FAlphaBlend" link="TCustomForm.AlphaBlend"/>
      <element name="TCustomForm.FAlphaBlendValue" link="TCustomForm.AlphaBlendValue"/>
      <element name="TCustomForm.FBorderIcons" link="TCustomForm.BorderIcons"/>
      <element name="TCustomForm.FDefaultControl" link="TCustomForm.DefaultControl"/>
      <element name="TCustomForm.FCancelControl" link="TCustomForm.CancelControl"/>
      <element name="TCustomForm.FDefaultMonitor" link="TCustomForm.DefaultMonitor"/>
      <element name="TCustomForm.FDesigner" link="TCustomForm.Designer"/>
      <element name="TCustomForm.FFormStyle" link="TCustomForm.FormStyle"/>
      <element name="TCustomForm.FFormUpdateCount" link="TCustomForm.FormIsUpdating"/>
      <element name="TCustomForm.FFormHandlers">
        <short>Lists of installed Form notification handlers</short>
      </element>
      <element name="TCustomForm.FHelpFile" link="TCustomForm.HelpFile"/>
      <element name="TCustomForm.FIcon" link="TCustomForm.Icon"/>
      <element name="TCustomForm.FOnShowModalFinished" link="TCustomForm.OnShowModalFinished"/>
      <element name="TCustomForm.FPopupMode" link="TCustomForm.PopupMode"/>
      <element name="TCustomForm.FPopupParent" link="TCustomForm.PopupParent"/>
      <element name="TCustomForm.FSmallIconHandle" link="TCustomForm.SmallIconHandle"/>
      <element name="TCustomForm.FBigIconHandle" link="TCustomForm.BigIconHandle"/>
      <element name="TCustomForm.FKeyPreview" link="TCustomForm.KeyPreview"/>
      <element name="TCustomForm.FMenu" link="TCustomForm.Menu"/>
      <element name="TCustomForm.FModalResult" link="TCustomForm.ModalResult"/>
      <element name="TScreen.FLastActiveControl">
        <short>The last active control, used to detect focus changes</short>
        <seealso>
          <link id="TScreen.RestoreLastActive"/>
        </seealso>
      </element>
      <element name="TCustomForm.FLastFocusedControl" link="TCustomForm.SetLastFocusedControl">
        <short>Used to track Focus changes (Enter/Exit events)</short>
      </element>
      <element name="TCustomForm.FOldBorderStyle" link="TCustomForm.DoDock"/>
      <element name="TCustomForm.FOnActivate" link="TCustomForm.OnActivate"/>
      <element name="TCustomForm.FOnClose" link="TCustomForm.OnClose"/>
      <element name="TCustomForm.FOnCloseQuery" link="TCustomForm.OnCloseQuery"/>
      <element name="TCustomForm.FOnCreate" link="TCustomForm.OnCreate"/>
      <element name="TCustomForm.FOnDeactivate" link="TCustomForm.OnDeactivate"/>
      <element name="TCustomForm.FOnDestroy" link="TCustomForm.OnDestroy"/>
      <element name="TCustomForm.FOnDropFiles" link="TCustomForm.OnDropFiles"/>
      <element name="TCustomForm.FOnHelp" link="TCustomForm.OnHelp"/>
      <element name="TCustomForm.FOnHide" link="TCustomForm.OnHide"/>
      <element name="TCustomForm.FOnShortcut" link="TCustomForm.OnShortcut"/>
      <element name="TCustomForm.FOnShow" link="TCustomForm.OnShow"/>
      <element name="TCustomForm.FOnWindowStateChange" link="TCustomForm.OnWindowStateChange"/>
      <element name="TCustomForm.FPosition" link="TCustomForm.Position"/>
      <element name="TCustomForm.FRestoredLeft" link="TCustomForm.RestoredLeft"/>
      <element name="TCustomForm.FRestoredTop" link="TCustomForm.RestoredTop"/>
      <element name="TCustomForm.FRestoredWidth" link="TCustomForm.RestoredWidth"/>
      <element name="TCustomForm.FRestoredHeight" link="TCustomForm.RestoredHeight"/>
      <element name="TCustomForm.FShowInTaskbar" link="TCustomForm.ShowInTaskBar"/>
      <element name="TCustomForm.FWindowState" link="TCustomForm.WindowState"/>
      <element name="TCustomForm.FDelayedEventCtr"/>
      <element name="TCustomForm.FDelayedWMMove"/>
      <element name="TCustomForm.FDelayedWMSize"/>
      <element name="TCustomForm.FIsFirstOnShow"/>
      <element name="TCustomForm.FIsFirstOnActivate"/>
      <element name="TCustomForm.GetClientHandle" link="TCustomForm.ClientHandle"/>
      <element name="TCustomForm.GetClientHandle.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetEffectiveShowInTaskBar">
        <short>
          Tries to resolve <var>stDefault</var> in <var>ShowInTaskBar</var> using <var>Application</var> settings.
        </short>
        <descr>
          <p>
            Calls ShowInTaskBar to get the visibility of an icon for the form.
          </p>
          <p>
            When the return value is stDefault (or when called at design-time), the TaskBarBehavior property in Application is taken into consideration to get the actual return value. If the application displays a single button for the executable and its forms, the return value is set to stNever. If multiple buttons can be displayed in the task bar, the value stAlways is used. If the Application uses the value tbDefault, the value stDefault is retained in the return value.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.ShowInTaskBar"/>
          <link id="TApplication.TaskBarBehavior"/>
          <link id="TShowInTaskbar"/>
          <link id="Application"/>
        </seealso>
      </element>
      <element name="TCustomForm.GetEffectiveShowInTaskBar.Result">
        <short>Effect visibility for the form icon in the task bar</short>
      </element>
      <element name="TCustomForm.GetMonitor" link="TCustomForm.Monitor">
        <short>Gets the value for the Monitor property</short>
      </element>
      <element name="TCustomForm.GetMonitor.Result">
        <short>Value for the property</short>
      </element>
      <element name="TCustomForm.IsAutoScrollStored" link="TCustomForm.AutoScroll"/>
      <element name="TCustomForm.IsAutoScrollStored.Result">
        <short/>
      </element>
      <element name="TCustomForm.IsForm">
        <short>Indicates whether Form properties should be stored in the stream</short>
        <descr>
          <p>
            <var>IsForm</var> is used as the storage specifier for selected properties in the class instance. Always returns <b>True</b> in <var>TCustomForm</var>.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Caption"/>
          <link id="TCustomForm.OnClose"/>
          <link id="TCustomForm.OnCloseQuery"/>
          <link id="TCustomForm.OnResize"/>
          <link id="TCustomForm.IsIconStored"/>
          <link id="TCustomForm.IsAutoScrollStored"/>
        </seealso>
      </element>
      <element name="TCustomForm.IsForm.Result">
        <short>
          True when the value for the various properties should be included in the LCL streaming mechanism
        </short>
      </element>
      <element name="TCustomForm.IsIconStored" link="TCustomForm.Icon"/>
      <element name="TCustomForm.IsIconStored.Result">
        <short/>
      </element>
      <element name="TCustomForm.CloseModal">
        <short>Closes a modal form</short>
        <descr>
          <p>
            <var>CloseModal</var> is a procedure which attempts to close a form that has been displayed by calling the <var>ShowModal</var> method.
          </p>
          <p>
            CloseModal calls <var>CloseQuery</var> to determine the action performed in the method. When CloseQuery returns <b>True</b>, the close action is set to <var>caHide</var> and the <var>OnClose</var> event handler is signalled when assigned. Form handlers are notified of the close action.
          </p>
          <p>
            When CloseQuery is <b>False</b>, the close action is used to determine how the request is handled. If the CloseAction is <var>caNone</var>, the value in <var>ModalResult</var> is set to <b>0</b> (<b>zero</b>). If the CloseAction is <var>caFree</var>, the <var>Release</var> method is called to allow the <var>Application</var> to free the form component.
          </p>
          <p>
            If an exception occurs in the method, the value in <var>ModalResult</var> is set to <b>0</b> (<b>zero</b>) and the <var>Application.HandleException</var> method is called.
          </p>
          <remark>
            Please note: <var>CloseModal</var> does not forward the action to the widget set class; that is performed in the <var>ShowModal</var> method to ensure it is executed in the widget set class.
          </remark>
        </descr>
        <seealso>
          <link id="TCustomForm.CloseQuery"/>
          <link id="TCustomForm.OnClose"/>
          <link id="TCustomForm.ModalResult"/>
          <link id="TCustomForm.Release"/>
          <link id="TCustomForm.AddHandler"/>
          <link id="TCustomForm.AddHandlerClose"/>
          <link id="TApplication.HandleException"/>
          <link id="TCloseAction"/>
        </seealso>
      </element>
      <element name="TCustomForm.FreeIconHandles">
        <short>Destroys the form icons</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.IconChanged">
        <short>Loads the new form icons, and notifies the widget set and all forms</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.IconChanged.Sender">
        <short/>
      </element>
      <element name="TCustomForm.DelayedEvent">
        <short>
          Performs actions needed for delayed window move, resize, show, and activate messages
        </short>
        <descr>
          <p>
            <var>DelayedEvent</var> are a mechanism used to reduce the number of move, resize, show, and activate messages that occur for forms and their child controls.
          </p>
          <p>
            <var>DelayedEvent</var> discards duplicate calls to the method; only the most recent message is processed. It is used in conjunction with the <var>QueueAsyncCall</var> method in <var>TApplication</var>. DelayedEvent decrements an internal counter used to track the number of pending delayed event messages. When the counter reaches zero (0), the message is applied.
          </p>
          <p>
            When <var>WindowState</var> is changed to <var>wsNormal</var>, the window origin or size is restored and <var>DoOnChangeBounds</var> is called. For delayed <var>WMSize</var> messages, the <var>DoOnShow</var> and/or <var>Activate</var> methods are called for the message.
          </p>
          <p>
            DelayedEvent is used in the implementation of the <var>WMSize</var> and <var>WMMove</var> methods.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
          <link id="TCustomForm.WindowState"/>
          <link id="TCustomForm.WMSize"/>
          <link id="TCustomForm.WMMove"/>
          <link id="TCustomForm.Activate"/>
          <link id="TCustomForm.DoShow"/>
          <link id="TScrollingWinControl.DoOnResize"/>
          <link id="TControl.DoOnChangeBounds"/>
        </seealso>
      </element>
      <element name="TCustomForm.DelayedEvent.Data">
        <short>
          An integer pointer to the data for the event; not used in the current implementation
        </short>
      </element>
      <element name="TCustomForm.SetActive" link="TCustomForm.Active"/>
      <element name="TCustomForm.SetActive.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetActiveControl" link="TCustomForm.ActiveControl"/>
      <element name="TCustomForm.SetActiveControl.AWinControl">
        <short/>
      </element>
      <element name="TCustomForm.SetActiveDefaultControl" link="TCustomForm.ActiveDefaultControl"/>
      <element name="TCustomForm.SetActiveDefaultControl.AControl">
        <short/>
      </element>
      <element name="TCustomForm.SetAllowDropFiles" link="TCustomForm.AllowDropFiles"/>
      <element name="TCustomForm.SetAllowDropFiles.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetAlphaBlend" link="TCustomForm.AlphaBlend"/>
      <element name="TCustomForm.SetAlphaBlend.AValue">
      <short/>
      </element>
      <element name="TCustomForm.SetAlphaBlendValue" link="TCustomForm.AlphaBlendValue"/>
      <element name="TCustomForm.SetAlphaBlendValue.AValue">
      <short/>
      </element>
      <element name="TCustomForm.SetBorderIcons" link="TCustomForm.BorderIcons"/>
      <element name="TCustomForm.SetBorderIcons.NewIcons">
        <short/>
      </element>
      <element name="TCustomForm.SetFormBorderStyle" link="TCustomForm.BorderStyle"/>
      <element name="TCustomForm.SetFormBorderStyle.NewStyle">
        <short/>
      </element>
      <element name="TCustomForm.SetCancelControl" link="TCustomForm.CancelControl"/>
      <element name="TCustomForm.SetCancelControl.NewControl">
        <short/>
      </element>
      <element name="TCustomForm.SetDefaultControl" link="TCustomForm.DefaultControl"/>
      <element name="TCustomForm.SetDefaultControl.NewControl">
        <short/>
      </element>
      <element name="TCustomForm.SetFormStyle" link="TCustomForm.FormStyle"/>
      <element name="TCustomForm.SetFormStyle.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetIcon" link="TCustomForm.Icon"/>
      <element name="TCustomForm.SetIcon.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetMenu" link="TCustomForm.Menu"/>
      <element name="TCustomForm.SetMenu.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetModalResult" link="TCustomForm.ModalResult"/>
      <element name="TCustomForm.SetModalResult.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetPopupMode" link="TCustomForm.PopupMode"/>
      <element name="TCustomForm.SetPopupMode.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetPopupParent" link="TCustomForm.PopupParent"/>
      <element name="TCustomForm.SetPopupParent.AValue">
        <short/>
      </element>
      <element name="TCustomForm.SetPosition" link="TCustomForm.Position"/>
      <element name="TCustomForm.SetPosition.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetShowInTaskbar" link="TCustomForm.ShowInTaskBar"/>
      <element name="TCustomForm.SetShowInTaskbar.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetLastFocusedControl">
        <short>Remembers the last focused control</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.SetLastFocusedControl.AControl">
        <short/>
      </element>
      <element name="TCustomForm.SetWindowFocus">
        <short>Called when the Focus changed</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TCustomForm.SetWindowState" link="TCustomForm.WindowState"/>
      <element name="TCustomForm.SetWindowState.Value">
        <short/>
      </element>
      <element name="TCustomForm.AddHandler">
        <short>Adds a form notification handler of the specified type</short>
        <descr/>
        <seealso>
          <link id="TFormHandlerType"/>
        </seealso>
      </element>
      <element name="TCustomForm.AddHandler.HandlerType">
        <short/>
      </element>
      <element name="TCustomForm.AddHandler.Handler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandler.AsFirst">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandler">
        <short>Removes a form notification handler of the specified type</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.RemoveHandler.HandlerType">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandler.Handler">
        <short/>
      </element>
      <element name="TCustomForm.FindDefaultForActiveControl">
        <short>Returns the first control in the form Tab order</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.FindDefaultForActiveControl.Result">
        <short/>
      </element>
      <element name="TCustomForm.UpdateMenu">
        <short>Called when the main menu has been changed</short>
        <descr>
          Don't show a main menu for dialog forms, i.e. when BorderStyle=bsDialog
          (Delphi compatible).
        </descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.UpdateShowInTaskBar">
        <short>Notifies the widget set of the change</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.WMActivate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMActivate.Message">
        <short/>
      </element>
      <element name="TCustomForm.WMCloseQuery">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>what does Result=0 mean?</note></notes>
      </element>
      <element name="TCustomForm.WMCloseQuery.message">
        <short/>
      </element>
      <element name="TCustomForm.WMDeactivate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMDeactivate.Message">
        <short/>
      </element>
      <element name="TCustomForm.WMHelp">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMHelp.Message">
        <short/>
      </element>
      <element name="TCustomForm.WMShowWindow">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMShowWindow.message">
        <short/>
      </element>
      <element name="TCustomForm.WMSize">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMSize.message">
        <short/>
      </element>
      <element name="TCustomForm.WMWindowPosChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.WMWindowPosChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMBiDiModeChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMBiDiModeChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMParentBiDiModeChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMParentBiDiModeChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMAppShowBtnGlyphChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMAppShowBtnGlyphChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMAppShowMenuGlyphChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMAppShowMenuGlyphChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMIconChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMIconChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMRelease">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMRelease.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMActivate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMActivate.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMDeactivate">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMDeactivate.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMShowingChanged">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMShowingChanged.Message">
        <short/>
      </element>
      <element name="TCustomForm.WMDPIChanged">
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.WMDPIChanged.Msg">
        <short></short>
      </element>
      <element name="TCustomForm.FActionLists">
        <short><var>FActionLists</var> is a local variable holding lists of actions associated with the Form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.FFormBorderStyle" link="TCustomForm.BorderStyle"/>
      <element name="TCustomForm.FFormState" link="TCustomForm.FormState"/>
      <element name="TCustomForm.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <element name="TCustomForm.DoShowWindow">
        <short>
          When a control is not Active, sets the Focus to the first control in the TabOrder for the form.
        </short>
      </element>
      <element name="TCustomForm.Activate">
        <short>Notifies the OnActivate handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.ActiveChanged">
        <short>Does nothing</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TCustomForm.AdjustClientRect">
        <short>Excludes borders from the given rectangle</short>
        <seealso>
          <link id="#LCL.Controls.TWinControl.AdjustClientRect">TWinControl.AdjustClientRect</link>
        </seealso>
      </element>
      <element name="TCustomForm.AdjustClientRect.Rect">
        <short/>
      </element>
      <element name="TCustomForm.BeginFormUpdate">
        <short>Locks form updates (AutoSize), until EndFormUpdate</short>
        <descr>Nested calls are allowed (pairs of Begin/EndFormUpdate).
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.ColorIsStored" link="#LCL.Controls.TControl.Color"/>
      <element name="TCustomForm.ColorIsStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomForm.CreateParams" link="#LCL.Controls.TWinControl.CreateParams"/>
      <element name="TCustomForm.CreateParams.Params">
        <short/>
      </element>
      <element name="TCustomForm.CreateWnd" link="#lcl.Controls.TWinControl.CreateWnd">
        <short>Creates the widget, updates the widget-dependent properties.
        </short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.CreateWnd">TWinControl.CreateWnd</link>
          <link id="#LCL.Forms.TScrollingWinControl.CreateWnd">TScrollingWinControl.CreateWnd</link>
        </seealso>
      </element>
      <element name="TCustomForm.Deactivate">
        <short>Called when the form looses the focus. Notifies the OnDeactivate handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.DoClose">
        <short>Notifies the form close handlers</short>
        <descr/>
        <seealso>
          <link id="TFormHandlerType.fhtClose"/>
          <link id="TCustomForm.OnClose"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoClose.CloseAction">
        <short/>
      </element>
      <element name="TCustomForm.DoCreate">
        <short>Notifies the form create handlers</short>
        <descr/>
        <seealso>
          <link id="TFormHandlerType.fhtCreate"/>
          <link id="TCustomForm.OnCreate"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoDestroy">
        <short>Notifies the <link id="TCustomForm.OnDestroy">OnDestroy</link> handler</short>
        <descr/>
        <seealso>
          <link id="TCustomForm.OnDestroy"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoHide">
        <short>Notifies the <link id="TCustomForm.OnHide">OnHide</link> handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.DoShow">
        <short>Notifies the <link id="TCustomForm.OnShow">OnShow</link> handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.EndFormUpdate">
        <short>Unlocks form updates; used with BeginFormUpdate</short>
        <descr>
          When the update counter reaches zero, FormEndUpdated is invoked to realize the pending changes.
        </descr>
        <seealso>
          <link id="TCustomForm.BeginFormUpdate"/>
          <link id="TCustomForm.FormEndUpdated"/>
        </seealso>
      </element>
      <element name="TCustomForm.HandleCreateException">
        <short>Placeholder for exception handlers in derived classes</short>
        <descr>By default the Application exception handler is invoked.</descr>
        <seealso>
          <link id="TApplication.HandleException"/>
          <link id="TApplication.CaptureExceptions"/>
        </seealso>
      </element>
      <element name="TCustomForm.HandleCreateException.Result">
        <short>True when the exception was handled</short>
      </element>
      <element name="TCustomForm.HandleDestroyException">
        <short>Placeholder for exception handlers in derived classes</short>
        <descr>By default the Application exception handler is invoked.</descr>
        <seealso>
          <link id="TApplication.HandleException"/>
          <link id="TApplication.CaptureExceptions"/>
        </seealso>
      </element>
      <element name="TCustomForm.HandleDestroyException.Result">
        <short>True when the exception was handled</short>
      </element>
      <element name="TCustomForm.HandleShowHideException">
        <short>Placeholder for exception handlers in derived classes</short>
        <descr>By default the Application exception handler is invoked.</descr>
        <seealso>
          <link id="TApplication.HandleException"/>
          <link id="TApplication.CaptureExceptions"/>
        </seealso>
      </element>
      <element name="TCustomForm.HandleShowHideException.Result">
        <short>True when the exception was handled</short>
      </element>
      <element name="TCustomForm.InitializeWnd" link="#LCL.Controls.TControl.InitializeWnd">
        <short>Initializes the widget, also for AlphaBlend and AllowDropFiles</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.Loaded">
        <short>Also renews ActiveControl and Visible</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TComponent.Loaded"/>
          <link id="#LCL.Forms.TScrollingWinControl.Loaded"/>
        </seealso>
      </element>
      <element name="TCustomForm.ChildHandlesCreated">
        <short>
          Called after all child control handles are created. When this is a
          top level form (Parent=Nil) also invokes ParentFormHandleInitialized.
        </short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.ChildHandlesCreated">TWinControl.ChildHandlesCreated</link>
        </seealso>
      </element>
      <element name="TCustomForm.Notification" link="#rtl.Classes.TComponent.Notification"/>
      <element name="TCustomForm.Notification.AComponent">
        <short/>
      </element>
      <element name="TCustomForm.Notification.Operation">
        <short/>
      </element>
      <element name="TCustomForm.PaintWindow" link="#LCL.Controls.TCustomControl.PaintWindow"/>
      <element name="TCustomForm.RequestAlign" link="#LCL.Controls.TControl.RequestAlign">
        <short>
          Calls the user Alignment handler (AlignControls). Here: NOP for a top-level form.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.Resizing">
        <short>
          Performs actions needed when the form processes the WMSize message
        </short>
        <descr>
          <p>
            Uses the value in <var>State</var> to determine the action required in the method. The LCL interface is used to detemine if the window state is valid for the widget set. When allowed, the following methods are called for the corresponding <var>TWindowState</var> value:
          </p>
          <dl>
            <dt>wsMinimized</dt>
            <dd>Calls the Minimize method in Application, or Restore if the Form is already minimized</dd>
          </dl>
          <p>
            When the <var>OnWindowStateChange</var> event handler has been assigned for the form, it is signalled for the current class instance.
          </p>
        </descr>
        <seealso>
          <link id="TScrollingWinControl.Resizing"/>
          <link id="TCustomForm.WMSize"/>
          <link id="TScrollingWinControl.WMSize"/>
          <link id="TCustomForm.OnWindowStateChange"/>
        </seealso>
      </element>
      <element name="TCustomForm.Resizing.State">
        <short>Window state applied in the method</short>
      </element>
      <element name="TCustomForm.CalculatePreferredSize" link="#LCL.Controls.TControl.CalculatePreferredSize">
        <short>Here: clip width and height of a top-level form to the monitor WorkArea</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.CalculatePreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TCustomForm.CalculatePreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TCustomForm.CalculatePreferredSize.WithThemeSpace">
        <short/>
      </element>
      <element name="TCustomForm.SetZOrder">
        <short>Here: Moves a top-level form in front or back of all forms</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.SetZOrder.Topmost">
        <short>True for BringToFront</short>
      </element>
      <element name="TCustomForm.SetParent" link="#LCL.Controls.TControl.Parent"/>
      <element name="TCustomForm.SetParent.NewParent">
        <short/>
      </element>
      <element name="TCustomForm.MoveToDefaultPosition" link="TCustomForm.Position">
        <short>Moves the form to the initial Position</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.UpdateShowing">
        <short>
          Called when the widget visibility (Showing) is changed. Updates (and realizes?) all properties affecting the visual representation for the form.
        </short>
        <descr/>
        <seealso>
          <link id="#LCL.Controls.TWinControl.UpdateShowing">TWinControl.UpdateShowing</link>
        </seealso>
      </element>
      <element name="TCustomForm.SetVisible" link="#LCL.Controls.TControl.SetVisible"/>
      <element name="TCustomForm.SetVisible.Value">
        <short>New value for the property</short>
      </element>
      <element name="TCustomForm.AllAutoSized" link="#LCL.Controls.TWinControl.AllAutoSized">
        <short>If the the form is about to show, calculate its metrics</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.DoFirstShow">
        <short>Notifies the FirstShow handlers</short>
        <descr/>
        <seealso>
          <link id="TFormHandlerType.fhtFirstShow"/>
        </seealso>
      </element>
      <element name="TCustomForm.UpdateWindowState">
        <short>UpdateWindowState is an empty implementation in TCustomForm</short>
        <descr/>
        <seealso/>
        <notes><note>An empty implementation in the current LCL version.</note></notes>
      </element>
      <element name="TCustomForm.VisibleChanging">
        <short>Notifies all <var>VisibleChanging</var> handlers</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.VisibleChanged">
        <short>Notifies all <var>VisibleChanged</var> handlers</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreenNotification.snFormVisibleChanged"/>
        </seealso>
      </element>
      <element name="TCustomForm.WndProc" link="#LCL.Controls.TControl.WndProc"/>
      <element name="TCustomForm.WndProc.TheMessage">
        <short>
          Handled messages include: Activate, SetFocus, KillFocus, Exit, Enter, Window Position Changing, and DrawItem
        </short>
      </element>
      <element name="TCustomForm.VisibleIsStored" link="TCustomForm.Visible"/>
      <element name="TCustomForm.VisibleIsStored.Result">
        <short/>
      </element>
      <element name="TCustomForm.DoAutoSize" link="#LCL.Controls.TControl.DoAutoSize"/>
      <element name="TCustomForm.SetAutoSize" link="#LCL.Controls.TControl.AutoSize"/>
      <element name="TCustomForm.SetAutoSize.Value">
        <short/>
      </element>
      <element name="TCustomForm.SetAutoScroll" link="TCustomForm.AutoScroll"/>
      <element name="TCustomForm.SetAutoScroll.Value">
        <short/>
      </element>
      <element name="TCustomForm.DoAddActionList">
        <short>Adds the specified list of actions to the ActionList for the form</short>
        <descr>
        </descr>
        <seealso>
          <link id="TCustomForm.RemoveActionList"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoAddActionList.List">
        <short/>
      </element>
      <element name="TCustomForm.DoRemoveActionList">
        <short>Removes an ActionList</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
          <link id="TCustomForm.AddActionList"/>
        </seealso>
      </element>
      <element name="TCustomForm.DoRemoveActionList.List">
        <short>List of actions removed in the method</short>
      </element>
      <element name="TCustomForm.ProcessResource">
        <short>Loads resources needed for the form</short>
        <descr>
          Calls InitResourceComponent to load form resources for the current form instance.
        </descr>
        <errors>
          Raises an EResNotFound exception if RequireDerivedFormResource is set for the application, and a resource is not found for the form.
        </errors>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.BeginAutoDrag">
        <short>Checked BeginDrag</short>
        <descr>
          Allow form dragging only if it is docked into a site without a DockManager.
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
        <notes><note>why?</note></notes>
      </element>
      <element name="TCustomForm.DoDock" link="#LCL.Controls.TControl.DoDock"/>
      <element name="TCustomForm.DoDock.NewDockSite">
        <short/>
      </element>
      <element name="TCustomForm.DoDock.ARect">
        <short/>
      </element>
      <element name="TCustomForm.GetFloating" link="#LCL.Controls.TControl.GetFloating"/>
      <element name="TCustomForm.GetFloating.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetDefaultDockCaption">
        <short>Here: returns the Caption</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.GetDefaultDockCaption.Result">
        <short/>
      </element>
      <element name="TCustomForm.CMActionExecute">
        <short>Handler for ActionExecute messages</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMActionExecute.Message">
        <short/>
      </element>
      <element name="TCustomForm.CMActionUpdate">
        <short>Handler for ActionUpdate messages</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.CMActionUpdate.Message">
        <short/>
      </element>
      <element name="TCustomForm.DoExecuteAction">
        <short>Asks all applicable components to execute an action</short>
        <descr>
          <p>
            First, the <var>ActiveControl</var> and the <var>Form</var> itself are asked to execute the action. Then, all child components are tried. The search stops as soon as the action is handled.
          </p>
        </descr>
      </element>
      <element name="TCustomForm.DoExecuteAction.Result">
        <short>True when the action was handled</short>
      </element>
      <element name="TCustomForm.DoExecuteAction.ExeAction">
        <short>Action to execute</short>
      </element>
      <element name="TCustomForm.DoUpdateAction">
        <short>Tries all applicable components to update an action</short>
        <descr/>
        <seealso>
          <link id="#LCL.Forms.TCustomForm.DoExecuteAction">DoExecuteAction</link>
        </seealso>
      </element>
      <element name="TCustomForm.DoUpdateAction.Result">
        <short>True when the action was updated</short>
      </element>
      <element name="TCustomForm.DoUpdateAction.TheAction">
        <short/>
      </element>
      <element name="TCustomForm.UpdateActions">
        <short>Asks all components to initiate their actions</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TCustomForm.ClientHandle">
        <short>The Handle of the MDIForm client (container for MDI children)</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TCustomForm.Create.AOwner">
        <short>Owner for the class instance</short>
      </element>
      <element name="TCustomForm.CreateNew">
        <short>Creates a form without a resource</short>
        <descr></descr>
        <seealso/>
      </element>
      <element name="TCustomForm.CreateNew.AOwner">
        <short>Owner for the new class instance</short>
      </element>
      <element name="TCustomForm.CreateNew.Num">
        <short>Here: ignored</short>
        <notes><note>purpose?</note></notes>
      </element>
      <element name="TCustomForm.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance.
          </p>
          <p>
            <var>Destroy</var> ensures that unhandled queued asynchronous calls in the <var>Application</var> instance are removed for the form.
          </p>
          <p>
            <var>Destroy</var> disables auto-sizing to prevent resize messages while the form is being freed. Destroy frees resources allocated for the form instance, including its Icon and any allocated icon handles. The form instance is removed from Screen, and its ActionLists are freed. Destroy frees all form handlers added to the class instance.
          </p>
          <p>
            Destroy calls the inherited destructor prior to exiting from the method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Icon"/>
          <link id="Application"/>
          <link id="Screen"/>
          <link id="TApplication"/>
          <link id="TScreen"/>
        </seealso>
      </element>
      <element name="TCustomForm.AfterConstruction"/>
      <element name="TCustomForm.BeforeDestruction"/>
      <element name="TCustomForm.GetControlClassDefaultSize" link="#LCL.Controls.TControl.GetControlClassDefaultSize"/>
      <element name="TCustomForm.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <element name="TCustomForm.BigIconHandle">
        <short>The Handle of the big form icon</short>
      </element>
      <element name="TCustomForm.BigIconHandle.Result">
        <short/>
      </element>
      <element name="TCustomForm.Close">
        <short>Closes the form</short>
        <descr>
          <p>
            Close does not necessarily destroy the form. Modal forms only are hidden. When the MainForm is closed, the application terminates.
          </p>
          <p>
            An <var>OnCloseQuery</var> handler can refuse to allow the form to close.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.CloseQuery"/>
        </seealso>
      </element>
      <element name="TCustomForm.CloseQuery">
        <short>Asks the OnCloseQuery handler whether the form can close</short>
        <descr/>
        <seealso>
          <link id="TCustomForm.OnCloseQuery"/>
        </seealso>
      </element>
      <element name="TCustomForm.CloseQuery.Result">
        <short/>
      </element>
      <element name="TCustomForm.DefocusControl">
        <short>Updates ActiveControl if it is to be defocused</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.DefocusControl.Control">
        <short>The control that looses the focus</short>
      </element>
      <element name="TCustomForm.DefocusControl.Removing">
        <short>True when the control is removed</short>
      </element>
      <element name="TCustomForm.DestroyWnd" link="#LCL.Controls.TWinControl.DestroyWnd"/>
      <element name="TCustomForm.EnsureVisible">
        <short>
          Ensures that the form is fully visible, and optionally brings it in front of all other forms
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.EnsureVisible.AMoveToTop">
        <short>Bring the form to front if True</short>
      </element>
      <element name="TCustomForm.FocusControl">
        <short>Focus the control. If needed bring form to front.</short>
        <descr/>
        <errors>
          If the control or one of its parents is not visible or disabled, an exception will be raised (in <var>SetFocus</var>).
        </errors>
        <seealso/>
        <notes><note>when? always?</note></notes>
      </element>
      <element name="TCustomForm.FocusControl.WinControl">
        <short>The control receiving the focus</short>
      </element>
      <element name="TCustomForm.FormIsUpdating" link="#LCL.Controls.TControl.FormIsUpdating">
        <short>
          Indicates if the BeginFormUpdate method has been called without a corresponding EndFormUpdate method call
        </short>
        <descr>
          <p>
            The method is used in <var>TControl</var> descendants to determine if the parent form for the control is already rendering changes to its content.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.BeginFormUpdate"/>
          <link id="TCustomForm.EndFormUpdate"/>
        </seealso>
      </element>
      <element name="TCustomForm.FormIsUpdating.Result">
        <short>
          Returns True when the internal update counter for the form contains a positive
          non-zero value
        </short>
      </element>
      <element name="TCustomForm.GetFormImage">
        <short>Makes a Bitmap image with the Form content</short>
      </element>
      <element name="TCustomForm.GetFormImage.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetRolesForControl">
        <short>The role(s) for the control in a modal form (default or cancel button)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.GetRolesForControl.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetRolesForControl.AControl">
        <short/>
      </element>
      <element name="TCustomForm.GetRealPopupParent">
        <short>
          Gets the form that is the effective parent for the pop-up, dialog, or splash screen
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.GetRealPopupParent.Result">
        <short>
          Form instance that is the parent for the pop-up form, or Nil for a splash screen
        </short>
      </element>
      <element name="TCustomForm.Hide" link="#LCL.Controls.TControl.Hide"/>
      <element name="TCustomForm.IntfDropFiles">
        <short>
          Invokes the <link id="TCustomForm.OnDropFiles">OnDropFiles</link> handler of the form. This function is called by the LCL interface.
        </short>
        <descr>
          <p>
            The drop files event will be invoked when the user drops one or more dragged files onto one of forms in the application. First this event should be fired for the target form (or main form if drop target is unknown), and then for the application instance.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.IntfDropFiles.FileNames">
        <short/>
      </element>
      <element name="TCustomForm.IntfHelp">
        <short>
          Show help for control or menu item. This function is called by the LCL interface.
        </short>
        <descr/>
        <seealso>
          <link id="#lcl.Controls.TControl.ShowHelp"/>
        </seealso>
       </element>
      <element name="TCustomForm.IntfHelp.AComponent">
        <short/>
      </element>
      <element name="TCustomForm.IsShortcut">
        <short>
          Asks all applicable components to interpret a keystroke as a shortcut. Returns True when the specified Key and Message are active as a shortcut.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.IsShortcut.Result">
        <short>True when the specified Key was handled as a shortcut.
        </short>
      </element>
      <element name="TCustomForm.IsShortcut.Message">
        <short/>
      </element>
      <element name="TCustomForm.MakeFullyVisible">
        <short>Extends or shrinks the form to a monitor</short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.MakeFullyVisible.AMonitor">
        <short>The monitor to use, Nil means the design-time monitor</short>
      </element>
      <element name="TCustomForm.MakeFullyVisible.UseWorkarea">
        <short>
          If True then extend to the WorkArea for the monitor. Otherwise, clip the form to the monitor bounds.
        </short>
      </element>
      <element name="TCustomForm.AutoSizeDelayedHandle">
        <short>
          Returns True if AutoSize should be skipped or delayed because of a missing handle
        </short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
        <notes><note>propagate back into TControl?</note></notes>
      </element>
      <element name="TCustomForm.AutoSizeDelayedHandle.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetPreferredSize" link="#LCL.Controls.TControl.GetPreferredSize"/>
      <element name="TCustomForm.GetPreferredSize.PreferredWidth">
        <short/>
      </element>
      <element name="TCustomForm.GetPreferredSize.PreferredHeight">
        <short/>
      </element>
      <element name="TCustomForm.GetPreferredSize.Raw">
        <short/>
      </element>
      <element name="TCustomForm.GetPreferredSize.WithThemeSpace">
        <short/>
      </element>
      <element name="TCustomForm.Release">
        <short>Marks the form for destruction</short>
        <descr>
          <p>
            <var>Release</var> is a procedure used to request destruction of the current form instance.
          </p>
          <p>
            <var>Release</var> checks for a <var>TApplication</var> instance in the <var>Application</var> singleton. When it is assigned (contains a value other than <b>Nil</b>), its <var>ReleaseComponent</var> method is called to free the form instance by posting an asynchronous application message. When <var>Application</var> is not assigned, the <var>Free</var> method is called to destroy the form instance.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ReleaseComponent"/>
          <link id="TCustomForm.Destroy"/>
          <link id="Application"/>
        </seealso>
      </element>
      <element name="TCustomForm.CanFocus">
        <short>True when the form can receive focus</short>
        <descr>
          <p>
            <var>CanFocus</var> is an overridden <var>Boolean</var> function which indicates if the form instance can receive focus. The return value is <b>True</b> when the form is <var>Visible</var> and <var>Enabled</var>, or the inherited <var>CanFocus</var> method returns <b>True</b>.
          </p>
          <p>
            <var>CanFocus</var> is used in the implementation of various methods in the class, including: <var>SetWindowFocus</var>, <var>UpdateShowing</var>, <var>SetActiveControl</var>, and <var>Loaded</var>.
          </p>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TCustomForm.CanFocus.Result">
        <short>True when the form can receive focus in the application</short>
      </element>
      <element name="TCustomForm.SetFocus" link="#LCL.Controls.TWinControl.SetFocus"/>
      <element name="TCustomForm.SetFocusedControl">
        <short>Handles focus switch to a control (enter/exit messages)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.SetFocusedControl.Result">
        <short>False when no switching allowed</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TCustomForm.SetFocusedControl.Control">
        <short>The control that received the focus</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TCustomForm.SetRestoredBounds">
        <short>Sets the bounds for the restored control</short>
        <descr>Temporarily goes into the normal (restored) window state, if required.</descr>
        <seealso/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.ALeft">
        <short/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.ATop">
        <short/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.AWidth">
        <short/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.AHeight">
        <short/>
      </element>
      <element name="TCustomForm.SetRestoredBounds.ADefaultPosition">
        <short/>
      </element>
      <element name="TCustomForm.Show" link="#LCL.Controls.TControl.Show"/>
      <element name="TCustomForm.ShowModal">
        <short>Show this form as a modal Dialog</short>
        <descr>
          <p>
            Shows the form in a modal state and waits until it is closed by the user or by the program. Modal state means that neither the user nor the program can switch to another form already made visible before calling <var>ShowModal</var>.
          </p>
          <p>
            The form must have <var>Visible</var> set to <b>False</b> when calling <var>ShowModal</var>. The call does <b>not</b> return until the form is closed. The application switches to modal state until <var>ShowModal</var> has completed.
          </p>
          <p>
            <var>ShowModal</var> creates its own event loop using <var>ProcessMessages</var>.
          </p>
        </descr>
        <errors>
          <p>
            Raises an <var>EInvalidOperation</var> exception if the form cannot be displayed as a modal form.
          </p>
        </errors>
        <seealso/>
      </element>
      <element name="TCustomForm.ShowModal.Result">
        <short>The modal result for the dialog</short>
      </element>
      <element name="TCustomForm.ShowOnTop">
        <short>Shows this form in front of all other forms</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.SmallIconHandle">
        <short>
          Returns (and eventually creates) the Handle of the small Form or Application Icon.
        </short>
        <seealso>
          <link id="TCustomForm.Icon"/>
        </seealso>
      </element>
      <element name="TCustomForm.SmallIconHandle.Result">
        <short/>
      </element>
      <element name="TCustomForm.GetChildren">
        <short>Invokes Proc for all Controls and also for all Components with no Parent</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TComponent.GetChildren">TComponent.GetChildren</link>
          <link id="#LCL.Controls.TWinControl.GetChildren">TWinControl.GetChildren</link>
        </seealso>
      </element>
      <element name="TCustomForm.GetChildren.Proc">
        <short>The callback method</short>
      </element>
      <element name="TCustomForm.GetChildren.Root">
        <short>Components are enumerated only if Root is Self</short>
      </element>
      <element name="TCustomForm.WantChildKey">
        <short></short>
        <descr>Always returns False in TCustomForm</descr>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TCustomForm.WantChildKey.Result">
        <short>Here: always False</short>
      </element>
      <element name="TCustomForm.WantChildKey.Child">
        <short/>
      </element>
      <element name="TCustomForm.WantChildKey.Message">
        <short/>
      </element>
      <element name="TCustomForm.RemoveAllHandlersOfObject" link="#LCL.LCLClasses.TLCLComponent.RemoveAllHandlersOfObject"/>
      <element name="TCustomForm.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerFirstShow">
        <short>Adds a handler for the first Show of the form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.AddHandlerFirstShow.OnFirstShowHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerFirstShow.AsFirst">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandlerFirstShow">
        <short>Removes a handler for the first Show of the form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.RemoveHandlerFirstShow.OnFirstShowHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerClose">
        <short>Adds a handler for form Close</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.AddHandlerClose.OnCloseHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerClose.AsFirst">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandlerClose">
        <short>Removes a handler for form Close</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.RemoveHandlerClose.OnCloseHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerCreate">
        <short>Adds a handler for form Create</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.AddHandlerCreate.OnCreateHandler">
        <short/>
      </element>
      <element name="TCustomForm.AddHandlerCreate.AsFirst">
        <short/>
      </element>
      <element name="TCustomForm.RemoveHandlerCreate">
        <short>Removes a handler for form Create</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.RemoveHandlerCreate.OnCreateHandler">
        <short/>
      </element>
      <element name="TCustomForm.ActiveMDIChild">
        <short>Returns the currently active MDI child form</short>
        <descr>
          A non-<b>nil</b> result is returned only when FormStyle contains <var>fsMDIForm</var> or <var>fsMDIChild</var>; otherwise Result is <b>nil</b>.
        </descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.ActiveMDIChild.Result">
        <short>Nil if the form is neither an MDI host nor child</short>
      </element>
      <element name="TCustomForm.GetMDIChildren" link="TCustomForm.MDIChildren"/>
      <element name="TCustomForm.GetMDIChildren.Result">
        <short>Nil if caller isn't an MDI type or handle isn't allocated</short>
      </element>
      <element name="TCustomForm.GetMDIChildren.AIndex">
        <short/>
      </element>
      <element name="TCustomForm.MDIChildCount" link="TCustomForm.MDIChildren"/>
      <element name="TCustomForm.MDIChildCount.Result">
        <short>-1 if caller isn't an MDI form or handle is not allocated</short>
      </element>
      <element name="TCustomForm.AutoScale">
        <short>Sets scaled to True and AutoAdjustLayout to current monitor PPI</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TCustomForm.Dock" link="#LCL.Controls.TControl.Dock"/>
      <element name="TCustomForm.Dock.NewDockSite">
        <short/>
      </element>
      <element name="TCustomForm.Dock.ARect">
        <short/>
      </element>
      <element name="TCustomForm.UpdateDockCaption" link="#LCL.Controls.TWinControl.UpdateDockCaption"/>
      <element name="TCustomForm.UpdateDockCaption.Exclude">
        <short/>
      </element>
      <element name="TCustomForm.Active">
        <short>Contains True when the form has the focus</short>
        <descr>Use active to check if the form has the focus</descr>
        <seealso/>
      </element>
      <element name="TCustomForm.ActiveControl">
        <short>Specifies the active control on the form</short>
        <descr>Use this to get or set the active control on this form.</descr>
        <seealso/>
      </element>
      <element name="TCustomForm.ActiveDefaultControl">
        <short>Specifies the Default control for the Form</short>
        <descr>The Default control reacts on the Enter key pressed.
        </descr>
        <seealso/>
      </element>
      <element name="TCustomForm.AllowDropFiles">
        <short>Specifies whether files can be dropped onto this form</short>
        <descr>
          <p>
            AllowDropFiles is a Boolean property which indicates whether this form receives an OnDropFiles event when files are dropped on form during a drag-and-drop operation.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.OnDropFiles"/>
        </seealso>
      </element>
      <element name="TCustomForm.AlphaBlend">
        <short>Allows for a translucent form</short>
        <descr>
        </descr>
        <seealso>
          <link id="TCustomForm.AlphaBlendValue"/>
        </seealso>
        <notes><note>somewhat transparent?</note></notes>
      </element>
      <element name="TCustomForm.AlphaBlendValue">
        <short>The translucence level for the form (0=transparent, 255=opaque)</short>
        <descr/>
        <seealso>
          <link id="TCustomForm.AlphaBlend"/>
        </seealso>
      </element>
      <element name="TCustomForm.AutoScroll">
        <short>Indicates if the form can automatically show or hide scroll bars</short>
        <descr>
          <p>
            <var>AutoScroll</var> is a <var>Boolean</var> property which indicates if the form can automatically show or hide its scroll bars. Set <var>AutoScroll</var> to <b>True</b> to enable scroll bars when the form size does not allow display of its content in its entirety. AutoScroll can only be True when the <var>BorderStyle</var> for the form is <var>bsSizeable</var> or <var>bsSizeToolWin</var>, and may be changed to <b>False</b> at run-time when setting the value in the BorderStyle property to another value.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.BorderStyle"/>
        </seealso>
      </element>
      <element name="TCustomForm.BorderIcons">
        <short>Specifies which icons appear in the title bar of the form</short>
        <descr>
          The icons can represent a system menu, minimize/restore/maximize and close buttons, and an <var>What's this</var> button.
        </descr>
        <seealso>
          <link id="TBorderIcon"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.BorderStyle">
        <short>
          The border style affects the title bar, border and resize behavior of the form.
        </short>
        <descr>
          <p>Use borderstyle to get or set the appearance of the form's border. </p>
          <p>By default it is a sizeable window, but it could, for example, be a dialog form
            or a tool window, or could be non-sizeable.</p>
          <p>This property is slightly different (has a different base type) from the
            <var>TCustomControl.BorderStyle</var> property. When the form is put into
            another control the window borders depend on the widget set. There are no
            borders under GTK.</p>
        </descr>
        <seealso>
          <link id="TCustomForm.AutoScroll"/>
          <link id="#lcl.Controls.TFormBorderStyle"/>
          <link id="#lcl.Controls.TBorderStyle"/>
          <link id="#lcl.Controls.TCustomControl.BorderStyle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.CancelControl">
        <short>The control associated with the Cancel action</short>
        <descr>
          <p>Determines the control associated with the Cancel action
            (exit from the modal form without changing anything).</p>
          <p>This is usually a button with the caption 'Cancel', but might
            be an 'Exit' button or anything else the application programmer decides.</p>
          <p>This control is selected either by explicitly clicking with the mouse,
            or by hitting the 'Esc' key.</p>
        </descr>
        <seealso>
          <link id="TCustomForm.DefaultControl"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Caption" link="#LCL.Controls.TControl.Caption">
        <short>The text appearing in the title bar</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Color" link="#LCL.Controls.TControl.Color">
        <short>The background color for the form</short>
        <descr>The form's background color.</descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.DefaultControl">
        <short>The control associated with the default action for this form</short>
        <descr>
          <p>
            This is typically a button such as 'Accept' which is highlighted in some way on-screen to indicate that this is the default action, and is selected either by hitting 'Return' or 'Enter' or by selecting that control with the mouse.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.DefaultMonitor">
        <short>The monitor on which the form will appear</short>
        <descr>
          <p>Possible values:</p>
          <dl>
            <dt>dmDesktop</dt>
            <dd>No attempt to choose specific monitor.</dd>
            <dt>dmPrimary</dt>
            <dd>On the primary monitor.</dd>
            <dt>dmMainForm </dt>
            <dd>On the same monitor as the main form. If there is no main form then use
              dmPrimary behavior.</dd>
            <dt>dmActiveForm</dt>
            <dd>On the same monitor as the currently active form. If there is no active
                form use dmMainForm behavior.</dd>
          </dl>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Designer">
        <short>The designer object when the form is in design state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.EffectiveShowInTaskBar">
        <short>
          Value from ShowInTaskBar adjusted for the default taskbar behavior in the application
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.FormState">
        <short>Various state flags for the form</short>
        <descr></descr>
        <seealso>
          <link id="TFormState"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.FormStyle">
        <short>Indicates the style for the form</short>
        <descr>
          <p> Possible values:</p>
          <dl>
            <dt>fsNormal </dt>
            <dd>Usual style.</dd>
            <dt>fsStayOnTop</dt>
            <dd>Form is positioned above all application's forms, except those which have
              fsStayOnTop style.</dd>
            <dt>fsSystemStayOnTop</dt>
            <dd>Form is positioned above all OS windows, except other OS top-level windows.</dd>
            <dt>fsSplash</dt>
            <dd>Form is border-less.</dd>
            <dt>fsMDIForm</dt>
            <dd>MDI parent form.</dd>
            <dt>fsMDIChild</dt>
            <dd>MDI child form.</dd>
          </dl>
        </descr>
        <seealso>
          <link id="#lcl.Controls.TFormStyle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.HelpFile">
        <short>The name of the help file for the form</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Icon">
        <short>The Icon associated with this Form (in minimized state)</short>
        <descr/>
        <seealso>
          <link id="TCustomForm.BigIconHandle"/>
          <link id="TCustomForm.SmallIconHandle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.KeyPreview">
        <short>Allows the form to intercept keystrokes in child controls</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.MDIChildren">
        <short>Provides indexed access to MDI child forms, when this is an MDI form</short>
        <descr>
        </descr>
        <seealso>
          <link id="TCustomForm.FormStyle"/>
        </seealso>
      </element>
      <element name="TCustomForm.MDIChildren.I">
        <short>Ordinal position for the MDI Child form requested</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Menu">
        <short>The main menu for this form</short>
        <descr>Drop a TMainMenu on the form to store it here and to show it on the form.</descr>
        <seealso>
          <link id="#lcl.Menus.TMainMenu"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.ModalResult">
        <short>Specifies the return value for a modal form (or dialog)</short>
        <descr>
        </descr>
        <seealso>
          <link id="TModalResult"/>
        </seealso>
      </element>
      <element name="TCustomForm.Monitor">
        <short>The Monitor where the form is shown</short>
      </element>
      <element name="TCustomForm.LastActiveControl">
        <short>
          Tracks changes in the focus for the active form or the control on the current form
        </short>
        <descr>
          <p>
            <var>LastActiveControl</var> is a read-only <var>TWinControl</var> property used to track a change in the focus for the active form or the control on the current form instance. It is updated when changes are made to the <var>ActiveControl</var> property, or in the <var>SetFocusedControl</var> method.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.ActiveControl"/>
          <link id="TCustomForm.SetFocusedControl"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.PopupMode">
        <short>Defines where popup menus are shown</short>
        <descr></descr>
        <seealso>
          <link id="TCustomForm.PopupParent"/>
          <link id="TPopupMode"/>
        </seealso>
        <notes><note>???</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.PopupParent">
        <short>
          Parent form which owns the current form instance when displayed as a pop-up window
        </short>
        <descr>
          <p>
            <var>PopupParent</var> is a <var>TCustomForm</var> property which contains the parent form which owns the current form instance when displayed as a pop-up window.
          </p>
          <p>
            Setting a new value for the property causes the existing pop-up parent form to be removed from the free notifications for the application. A new non-Nil pop-up parent is added to the free notification list, and its <var>PopupMode</var> property is set to <var>pmExplicit</var>.
          </p>
          <p>
            At run-time, the widget set class is notified of the change in the <var>PopupParent</var> property. The notification is not performed at design-time.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.PopupMode"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnActivate">
        <short>Handler called when the form receives focus</short>
        <descr>
          <p>
            This handler is called when the form receives focus for the first time at application start up, and then subsequently each time focus is changed from another window for the same application to this window.
          </p>
          <p>
            For focus changes between different applications, the <var>Application.OnActivate</var> event handler is called instead.
          </p>
        </descr>
        <seealso>
          <link id="#LCL.Forms.TApplication.OnActivate">TApplication.OnActivate</link>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnClose">
        <short>
          Handler called when the form is closed. It determines what happens to the form (destroy, hide...).
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnCloseQuery">
        <short>
          Handler called before the form is closed. It can reject an close request.
        </short>
        <descr>
          <p>
            An <var>OnCloseQuery</var> handler can check for unsaved information, ask the user whether it's okay to save or discard changes, or simply reject the close request.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnCreate">
        <short>Handler called when the form has been created</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnDeactivate">
        <short>Handler called when the form is deactivated (lost focus)</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnDeactivate"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnDestroy">
        <short>Handler called when the form is destroyed</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnDropFiles">
        <short>Handler called when files have been dropped</short>
        <descr>
          You enable this feature by setting AllowDropFiles property.
        </descr>
        <seealso>
          <link id="TCustomForm.AllowDropFiles"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnHelp">
        <short>Handler called when Help is requested</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnHide">
        <short>Handler called when the form is being hidden</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnResize" link="#LCL.Controls.TControl.OnResize"/>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnShortcut">
        <short>Handler called when a key is pressed, before further handling of the key</short>
        <descr>
          The handler can interpret the key as an shortcut and act accordingly.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnShow">
        <short>Handler called when the form becomes visible</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.OnShowModalFinished">
        <short>Event handler signalled when modal display of the form has been completed</short>
        <descr>
          <p>
            <var>OnShowModalFinished</var> is a <var>TModalDialogFinished</var> property that implements the event handler signalled when modal display of the form has been completed. An application must implement an object procedure using the signature in <var>TModalDialogFinished</var>, and assign it to the property to respond to the event notification.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ModalFinished"/>
          <link id="TApplication.OnModalEnd"/>
        </seealso>
        <notes>
          <note>
            Is this a remnant? Not used in ShowModal or CloseModal. It does not appear to be used anywhere in the current LCL version.
          </note>
        </notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.OnWindowStateChange">
        <short>Handler called when the form is minimized, maximized or restored</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomForm.ParentFont" link="#LCL.Controls.TControl.ParentFont"/>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Position">
        <short>The initial placement of the form</short>
        <descr>By default it is in the position that it was placed in the Form Designer</descr>
        <seealso>
          <link id="TPosition"/>
          <link id="TCustomForm.DefaultMonitor"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.RestoredLeft">
        <short>The position of the left edge of the form when it is restored (i.e. changes from minimized or maximized)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.RestoredTop">
        <short>The position of the top edge of the form when it is restored (i.e. changes from minimized or maximized)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.RestoredWidth">
        <short>The width of the form when it is restored (i.e. changes from minimized or maximized)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.RestoredHeight">
        <short>The height of the form when it is restored (i.e. changes from minimized or maximized)</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.ShowInTaskBar">
        <short>How the form is represented in the system Task Bar</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomForm.Visible" link="#LCL.Controls.TControl.Visible"/>
      <!-- property Visibility: public -->
      <element name="TCustomForm.WindowState">
        <short>Whether the form is currently minimized, maximized or normal (restored).
        </short>
        <descr>Default is 'normal' (i.e. not minimized nor maximized)</descr>
        <seealso>
          <link id="TWindowState"/>
        </seealso>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="TCustomFormClass" link="TCustomForm"/>
      <!-- object Visibility: default -->
      <element name="TForm">
      </element>
      <!-- variable Visibility: private -->
      <element name="TForm.FLCLVersion" link="TForm.LCLVersion"/>
      <!-- function Visibility: private -->
      <element name="TForm.LCLVersionIsStored" link="TForm.LCLVersion"/>
      <element name="TForm.LCLVersionIsStored.Result">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TForm.CreateWnd" link="#lcl.Controls.TWinControl.CreateWnd"/>
      <element name="TForm.Loaded" link="#LCL.Forms.TCustomForm.Loaded"/>
      <element name="TForm.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TForm.Create.TheOwner">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TForm.Cascade">
        <short>Arranges MDI child forms so they overlap</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TForm.Next">
        <short>Activates the next child MDI form (fsMDIChild) in the form sequence</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TForm.Previous">
        <short>Activates the previous MDI child form in the form sequence</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TForm.Tile">
        <short>Arranges MDI child forms side by side</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TForm.ClientHandle" link="TCustomForm.ClientHandle"/>
      <element name="TForm.DockManager" link="#LCL.Controls.TWinControl.DockManager"/>
      <!-- property Visibility: published -->
      <element name="TForm.Action" link="#LCL.Controls.TControl.Action"/>
      <element name="TForm.ActiveControl" link="TCustomForm.ActiveControl"/>
      <element name="TForm.Align" link="#LCL.Controls.TControl.Align"/>
      <element name="TForm.AllowDropFiles" link="TCustomForm.AllowDropFiles"/>
      <element name="TForm.AlphaBlend" link="TCustomForm.AlphaBlend"/>
      <element name="TForm.AlphaBlendValue" link="TCustomForm.AlphaBlendValue"/>
      <element name="TForm.Anchors" link="#LCL.Controls.TControl.Anchors"/>
      <element name="TForm.AutoScroll" link="TScrollingWinControl.AutoScroll"/>
      <element name="TForm.AutoSize" link="#LCL.Controls.TControl.AutoSize"/>
      <element name="TForm.BiDiMode" link="#LCL.Controls.TControl.BiDiMode"/>
      <element name="TForm.BorderIcons" link="TCustomForm.BorderIcons"/>
      <element name="TForm.BorderStyle" link="TCustomForm.BorderStyle"/>
      <element name="TForm.BorderWidth" link="#LCL.Controls.TWinControl.BorderWidth"/>
      <element name="TForm.Caption" link="#LCL.Controls.TControl.Caption"/>
      <element name="TForm.ChildSizing" link="#LCL.Controls.TWinControl.ChildSizing"/>
      <element name="TForm.ClientHeight" link="#LCL.Controls.TControl.ClientHeight"/>
      <element name="TForm.ClientWidth" link="#LCL.Controls.TControl.ClientWidth"/>
      <element name="TForm.Color" link="#LCL.Controls.TControl.Color"/>
      <element name="TForm.Constraints" link="#LCL.Controls.TControl.Constraints"/>
      <element name="TForm.DefaultMonitor" link="TCustomForm.DefaultMonitor"/>
      <element name="TForm.DesignTimePPI" link="TCustomDesignControl.DesignTimePPI"/>
      <element name="TForm.DockSite" link="#LCL.Controls.TWinControl.DockSite"/>
      <element name="TForm.DoubleBuffered" link="#LCL.Controls.TControl.DoubleBuffered"/>
      <element name="TForm.DragKind" link="#LCL.Controls.TControl.DragKind"/>
      <element name="TForm.DragMode" link="#LCL.Controls.TControl.DragMode"/>
      <element name="TForm.Enabled" link="#LCL.Controls.TControl.Enabled"/>
      <element name="TForm.Font" link="#LCL.Controls.TControl.Font"/>
      <element name="TForm.FormStyle" link="TCustomForm.FormStyle"/>
      <element name="TForm.HelpFile" link="TCustomForm.HelpFile"/>
      <element name="TForm.Icon" link="TCustomForm.Icon"/>
      <element name="TForm.KeyPreview" link="TCustomForm.KeyPreview"/>
      <element name="TForm.Menu" link="TCustomForm.Menu"/>
      <element name="TForm.OnActivate" link="TCustomForm.OnActivate"/>
      <element name="TForm.OnChangeBounds" link="#LCL.Controls.TControl.OnChangeBounds"/>
      <element name="TForm.OnClick" link="#LCL.Controls.TControl.OnClick"/>
      <element name="TForm.OnClose" link="TCustomForm.OnClose"/>
      <element name="TForm.OnCloseQuery" link="TCustomForm.OnCloseQuery"/>
      <element name="TForm.OnContextPopup" link="TCustomForm.OnContextPopup"/>
      <element name="TForm.OnCreate" link="TCustomForm.OnCreate"/>
      <element name="TForm.OnDblClick" link="#LCL.Controls.TControl.OnDblClick"/>
      <element name="TForm.OnDeactivate" link="TCustomForm.OnDeactivate"/>
      <element name="TForm.OnDestroy" link="TCustomForm.OnDestroy"/>
      <element name="TForm.OnDockDrop" link="#LCL.Controls.TWinControl.OnDockDrop"/>
      <element name="TForm.OnDockOver" link="#LCL.Controls.TWinControl.OnDockOver"/>
      <element name="TForm.OnDragDrop" link="#LCL.Controls.TControl.OnDragDrop"/>
      <element name="TForm.OnDragOver" link="#LCL.Controls.TControl.OnDragOver"/>
      <element name="TForm.OnDropFiles" link="TCustomForm.OnDropFiles"/>
      <element name="TForm.OnEndDock" link="#LCL.Controls.TControl.OnEndDock"/>
      <element name="TForm.OnGetSiteInfo" link="#LCL.Controls.TWinControl.OnGetSiteInfo"/>
      <element name="TForm.OnHelp" link="TCustomForm.OnHelp"/>
      <element name="TForm.OnHide" link="TCustomForm.OnHide"/>
      <element name="TForm.OnKeyDown" link="#LCL.Controls.TWinControl.OnKeyDown"/>
      <element name="TForm.OnKeyPress" link="#LCL.Controls.TWinControl.OnKeyPress"/>
      <element name="TForm.OnKeyUp" link="#LCL.Controls.TWinControl.OnKeyUp"/>
      <element name="TForm.OnMouseDown" link="#LCL.Controls.TControl.OnMouseDown"/>
      <element name="TForm.OnMouseEnter" link="#LCL.Controls.TControl.OnMouseEnter"/>
      <element name="TForm.OnMouseLeave" link="#LCL.Controls.TControl.OnMouseLeave"/>
      <element name="TForm.OnMouseMove" link="#LCL.Controls.TControl.OnMouseMove"/>
      <element name="TForm.OnMouseUp" link="#LCL.Controls.TControl.OnMouseUp"/>
      <element name="TForm.OnMouseWheel" link="#LCL.Controls.TControl.OnMouseWheel"/>
      <element name="TForm.OnMouseWheelDown" link="#LCL.Controls.TControl.OnMouseWheelDown"/>
      <element name="TForm.OnMouseWheelUp" link="#LCL.Controls.TControl.OnMouseWheelUp"/>
      <element name="TForm.OnPaint" link="#LCL.Controls.TCustomControl.OnPaint"/>
      <element name="TForm.OnResize" link="#LCL.Controls.TControl.OnResize"/>
      <element name="TForm.OnShortCut" link="TCustomForm.OnShortcut"/>
      <element name="TForm.OnShow" link="TCustomForm.OnShow"/>
      <element name="TForm.OnShowHint" link="#LCL.Controls.TControl.OnShowHint"/>
      <element name="TForm.OnStartDock" link="#LCL.Controls.TControl.OnStartDock"/>
      <element name="TForm.OnUnDock" link="#LCL.Controls.TWinControl.OnUnDock"/>
      <element name="TForm.OnUTF8KeyPress" link="#LCL.Controls.TWinControl.OnUTF8KeyPress"/>
      <element name="TForm.OnWindowStateChange" link="TCustomForm.OnWindowStateChange"/>
      <element name="TForm.ParentBiDiMode" link="#LCL.Controls.TControl.ParentBiDiMode"/>
      <element name="TForm.ParentDoubleBuffered" link="#LCL.Controls.TControl.ParentDoubleBuffered"/>
      <element name="TForm.ParentFont" link="#LCL.Controls.TControl.ParentFont"/>
      <element name="TForm.PixelsPerInch" link="TCustomForm.PixelsPerInch"/>
      <element name="TForm.PopupMenu" link="#LCL.Controls.TControl.PopupMenu"/>
      <element name="TForm.PopupMode" link="TCustomForm.PopupMode"/>
      <element name="TForm.PopupParent" link="TCustomForm.PopupParent"/>
      <element name="TForm.Position" link="TCustomForm.Position"/>
      <element name="TForm.SessionProperties" link="#LCL.Controls.TControl.SessionProperties"/>
      <element name="TForm.ShowHint" link="#LCL.Controls.TControl.ShowHint"/>
      <element name="TForm.ShowInTaskBar" link="TCustomForm.ShowInTaskBar"/>
      <element name="TForm.UseDockManager" link="#LCL.Controls.TWinControl.UseDockManager"/>
      <element name="TForm.LCLVersion">
        <short>The version of the LCL as string. Used to distinguish form streams using
          different versions of the LCL</short>
      </element>
      <element name="TForm.Scaled"/>
      <element name="TForm.Visible" link="#LCL.Controls.TControl.Visible"/>
      <element name="TForm.WindowState" link="TCustomForm.WindowState"/>
      <!-- "class of" type Visibility: default -->
      <element name="TFormClass" link="TForm">
        <short>Class of <var>TForm</var></short>
        <descr/>
        <seealso/>
      </element>
      <!-- object Visibility: default -->
      <element name="TCustomDockForm">
        <short>A floating DockSite, usable to make TControls float</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomDockForm.DoAddDockClient" link="#LCL.Controls.TWinControl.DoAddDockClient">
        <short>Makes the client occupy the entire client area (alClient)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomDockForm.DoAddDockClient.Client">
        <short/>
      </element>
      <element name="TCustomDockForm.DoAddDockClient.ARect">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomDockForm.DoRemoveDockClient" link="#LCL.Controls.TWinControl.DoRemoveDockClient">
        <short>Closes (releases) the form after the last client has been undocked</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomDockForm.DoRemoveDockClient.Client">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomDockForm.GetSiteInfo" link="#LCL.Controls.TWinControl.GetSiteInfo">
        <short>Disallows docking of an second client</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TCustomDockForm.GetSiteInfo.Client">
        <short/>
      </element>
      <element name="TCustomDockForm.GetSiteInfo.InfluenceRect">
        <short/>
      </element>
      <element name="TCustomDockForm.GetSiteInfo.MousePos">
        <short/>
      </element>
      <element name="TCustomDockForm.GetSiteInfo.CanDock">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TCustomDockForm.Loaded" link="#LCL.Forms.TCustomForm.Loaded">
        <short>
          Tries to make all child controls dockclients. This is of little use in practice,
          a floating hostdocksite should have no child controls.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TCustomDockForm.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TCustomDockForm.Create.TheOwner">
        <short>Owner for the class instance</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TCustomDockForm.AutoScroll" link="#LCL.Forms.TScrollingWinControl.AutoScroll"/>
      <element name="TCustomDockForm.BorderStyle" link="#LCL.Forms.TCustomForm.BorderStyle"/>
      <element name="TCustomDockForm.FormStyle" link="#LCL.Forms.TCustomForm.FormStyle"/>
      <element name="TCustomDockForm.PixelsPerInch" link="#LCL.Forms.TCustomForm.PixelsPerInch"/>
      <!-- object Visibility: default -->
      <element name="THintWindow">
        <short>
          The popup box containing helpful information that appears when the mouse pointer hovers over an object
        </short>
        <descr>
          <p>Usage:</p>
<code>
 HintWindow := THintWindow.Create(nil);
 Rect := HintWindow.CalcHintRect(0,'This is the hint',nil);
 HintWindow.ActivateHint(Rect,'This is the hint');
</code>
        </descr>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="THintWindow.FActivating">
        <short>True during ActivateHint</short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindow.FAlignment" link="THintWindow.Alignment"/>
      <element name="THintWindow.FHintRect"/>
      <element name="THintWindow.FHintData"/>
      <element name="THintWindow.FAutoHide" link="THintWindow.AutoHide"/>
      <element name="THintWindow.FAutoHideTimer">
        <short>The timer used to make the hint disappear</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: private -->
      <element name="THintWindow.FHideInterval" link="THintWindow.HideInterval"/>
      <element name="THintWindow.AdjustBoundsForMonitor">
        <short>Adjusts HintRect to fit on the current monitor</short>
        <descr>Used in the implementation of the OffsetHintRect method.</descr>
        <seealso>
          <link id="THintWindow.HintRect"/>
          <link id="THintWindow.HintRectAdjust"/>
          <link id="THintWindow.OffsetHintRect"/>
        </seealso>
      </element>
      <element name="THintWindow.AdjustBoundsForMonitor.KeepWidth">
        <short>Indicates that the width for HintRect should not be decreased</short>
      </element>
      <element name="THintWindow.AdjustBoundsForMonitor.KeepHeight">
        <short>Indicates that the height for HintRect should not be decreased</short>
      </element>
      <!-- function Visibility: private -->
      <element name="THintWindow.GetDrawTextFlags">
        <short>Collects the flags for Draw Text formatting</short>
        <descr>
          <p>
            Returns a Cardinal value that contains the Draw Text flags needed for the Alignment and BiDiMode used in the hint window.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.Alignment"/>
          <link id="THintWindow.BiDiMode"/>
        </seealso>
      </element>
      <element name="THintWindow.GetDrawTextFlags.Result">
        <short>Draw Text flags for the hint window</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="THintWindow.SetAutoHide" link="THintWindow.AutoHide"/>
      <element name="THintWindow.SetAutoHide.Value">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="THintWindow.AutoHideHint">
        <short>Hides the hint window when the hint timer has expired</short>
        <descr>
          <p>
            Called when the hint timer expires. Ensures that the internal hint timer is disabled. Hides the hint window by setting the <var>Visible</var> property to <b>False</b>.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.AutoHide"/>
          <link id="THintWindow.HideInterval"/>
        </seealso>
      </element>
      <element name="THintWindow.AutoHideHint.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="THintWindow.SetHideInterval" link="THintWindow.HideInterval"/>
      <element name="THintWindow.SetHideInterval.Value">
        <short>New value for the property</short>
      </element>
      <element name="THintWindow.SetHintRectAdjust">
        <short>Sets the value for the HintRectAdjust property</short>
        <descr></descr>
        <seealso>
          <link id="THintWindow.HintRectAdjust"/>
        </seealso>
      </element>
      <element name="THintWindow.SetHintRectAdjust.AValue">
        <short>New value for the property</short>
      </element>
      <element name="THintWindow.WSRegisterClass" link="#LCL.LCLClasses.TLCLComponent.WSRegisterClass"/>
      <!-- procedure Visibility: protected -->
      <element name="THintWindow.WMNCHitTest">
        <short>Treats the whole window as transparent</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindow.WMNCHitTest.Message">
        <short/>
      </element>
      <element name="THintWindow.ActivateSub">
        <short>Sets the bounds for the hint window and configures the auto-hide timer</short>
        <descr>
          <p>
            Sets the bounds for the hint window to the values in the <var>HintRect</var> property, and makes the window <var>Visible</var>. The internal auto-hide timer is enabled when <var>AutoHide</var> contains <b>True</b>.
          </p>
          <p>
            Called from the ActivateHint method.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.HintRect"/>
          <link id="THintWindow.AutoHide"/>
          <link id="THintWindow.Visible"/>
          <link id="THintWindow.ActivateHint"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="THintWindow.DoShowWindow" link="#LCL.Forms.TCustomForm.DoShowWindow"/>
      <!-- procedure Visibility: protected -->
      <element name="THintWindow.UpdateRegion">
        <short>Updates the Window Region fir the hint window</short>
        <descr>
          <p>
            <var>UpdateRegion</var> calls the <var>SetWindowRgn</var> routine to set the window region for the hint window. The window region contains the area where the system can perform drawing operations; no area outside of the window region can be updated.
          </p>
          <remark>
            Please note: <var>SetWindowRgn</var> requires access to the Handle for the hint window; no actions are performed in the method when <var>HandleAllocated</var> returns <b>False</b>.
          </remark>
          <p>
            When <var>UseBGThemes</var> is enabled, <var>ThemeServices</var> are used to get the theme element details needed for the client rectangle in the hint window.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.UseBGThemes"/>
          <link id="THintWindow.UseBGThemes"/>
        </seealso>
      </element>
      <element name="THintWindow.SetColor">
        <short>Sets the value for the Color property</short>
        <descr/>
        <seealso>
          <link id="THintWindow.Color"/>
        </seealso>
      </element>
      <element name="THintWindow.SetColor.Value">
        <short>New value for the property</short>
      </element>
      <element name="THintWindow.UseBGThemes">
        <short>
          Indicates if a background from theme services is used when drawing the hint window
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindow.UseBGThemes.Result">
        <short>True when ThemeServices are used for the background</short>
      </element>
      <element name="THintWindow.UseFGThemes">
        <short>
          Indicates if theme services are used for the foreground rendered for the hint window
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindow.UseFGThemes.Result">
        <short>
          True when ThemeServices are used to draw the foreground for the hint window
        </short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="THintWindow.Paint" link="#LCL.Controls.TCustomControl.Paint"/>
      <element name="THintWindow.FSysHintFont"/>
      <element name="THintWindow.SysHintFont">
        <short>System font used to draw text in the hint window</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindow.SysHintFont.Result">
        <short>TFont instance for the system font provided by the widget set</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="THintWindow.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            Destroy is a class destructor. Destroy ensures a reference to the System Font used for hint windows is freed.
          </p>
        </descr>
        <seealso></seealso>
      </element>
      <!-- constructor Visibility: public -->
      <element name="THintWindow.Create" link="#rtl.Classes.TComponent.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            <var>Create</var> is the overridden constructor for the class instance. Create calls the inherited <var>CreateNew</var> constructor, and allocates resources needed in the class instance. This includes an internal timer used when <var>AutoHide</var> is set to <b>True</b>.
          </p>
          <p>
            Create sets the default values for the following properties:
          </p>
          <dl>
            <dt>Parent</dt>
            <dd>Set to Nil</dd>
            <dt>Color</dt>
            <dd>Set to clInfoBk</dd>
            <dt>Font</dt>
            <dd>Uses the Screen.HintFont</dd>
            <dt>Canvas</dt>
            <dd>Uses the brush style bsClear</dd>
            <dt>Alignment</dt>
            <dd>Set to taLeftJustify</dd>
            <dt>BorderStyle</dt>
            <dd>Set to bsNone</dd>
            <dt>Caption</dt>
            <dd>Set to an empty string ('')</dd>
            <dt>HideInterval</dt>
            <dd>Set to 3000 milliseconds (3 seconds)</dd>
            <dt>AutoHide</dt>
            <dd>Set to False</dd>
          </dl>
          <p>
            Create uses the default size from the class type for the control to set the initial bounds for the hint window.
          </p>
        </descr>
        <seealso></seealso>
      </element>
      <element name="THintWindow.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.ActivateHint">
        <short>Shows the specified hint</short>
        <descr>
          <p>
            <var>ActivateHint</var> is an overloaded procedure used to display the Hint text specified in <var>AHint</var>. An overloaded variant allows the display area for the hint window to be specified in the <var>ARect</var> argument.
          </p>
          <remark>
            Please note: No actions are performed in the method if <var>ActivateHint</var> has been previously called with the same hint text and display area.
          </remark>
        </descr>
        <seealso>
          <link id="THintWindow.CalcHintRect"/>
        </seealso>
      </element>
      <element name="THintWindow.ActivateHint.AHint">
        <short>Text displayed in the hint window</short>
      </element>
      <element name="THintWindow.ActivateHint.ARect">
        <short>TRect with the display area for the hint window</short>
      </element>
      <element name="THintWindow.ActivateWithBounds">
        <short>Sets the bounds in HintRect and activates the hint window</short>
        <descr>
          <p>
            <var>ActivateWithBounds</var> is a procedure used to update the location and text for the hint window. ActivateWithBounds sets the value in <var>HintRect</var> to the value in the <var>ARect</var> argument. ActivateWithBounds calls <var>ActivateHint</var> using the value in <var>AHint</var> as the text displayed in the hint window.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.HintRect"/>
          <link id="THintWindow.ActivateHint"/>
        </seealso>
      </element>
      <element name="THintWindow.ActivateWithBounds.ARect">
        <short>Rectangle with the bounds assigned to HintRect</short>
      </element>
      <element name="THintWindow.ActivateWithBounds.AHint">
        <short>Text displayed in the hint window</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.ActivateHintData">
        <short>
          An extended version of ActivateHint with additional data used for the hint display
        </short>
        <descr>
          <p>
            <var>ActivateHintData</var> is an extended version of <var>ActivateHint</var>. It provides the additional <var>AData</var> argument which contains a pointer to values which can be used to construct  the text displayed in the hint window.
           </p>
          <p>
            The implementation in <var>THintWindow</var> does not use the values in <var>AData</var>. The method must be overridden in a descendent class to use the additional hint data in <var>AData</var>.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.ActivateHint"/>
        </seealso>
      </element>
      <element name="THintWindow.ActivateHintData.ARect">
        <short>Display rectangle for the hint text</short>
      </element>
      <element name="THintWindow.ActivateHintData.AHint">
        <short>Text displayed in the hint window</short>
      </element>
      <element name="THintWindow.ActivateHintData.AData">
        <short>Pointer to additional data used to construct the hint text</short>
      </element>
      <!-- function Visibility: public -->
      <element name="THintWindow.CalcHintRect">
        <short>Determines the rectangle required for the hint display</short>
        <descr>
          <p>
            CalcHintRect determines the display rectangle required for the hint display. CalcHintRect uses the larger of the values in the length of the hint text, and the width of the hint window.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="THintWindow.CalcHintRect.Result">
        <short>Display area needed for the hint display</short>
      </element>
      <element name="THintWindow.CalcHintRect.MaxWidth">
        <short>Greater than zero, otherwise the full monitor width is used</short>
      </element>
      <element name="THintWindow.CalcHintRect.AHint">
        <short>Hint text used to derive the display area</short>
      </element>
      <element name="THintWindow.CalcHintRect.AData">
        <short>Pointer to additional data used to construct the hint text</short>
      </element>
      <element name="THintWindow.OffsetHintRect">
        <short>Moves the hint rectangle by the specified amounts</short>
        <descr></descr>
        <seealso>
          <link id="THintWindow.HintRect"/>
          <link id="THintWindow.HintRectAdjust"/>
          <link id="THintWindow.AdjustBoundsForMonitor"/>
        </seealso>
      </element>
      <element name="THintWindow.OffsetHintRect.Result">
        <short>
          True when the hint rectangle was successfully moved by the specified amounts
        </short>
      </element>
      <element name="THintWindow.OffsetHintRect.AOffset">
        <short>TPoint with the horizontal and vertical offets for the hint display</short>
      </element>
      <element name="THintWindow.OffsetHintRect.dy">
        <short>Additional vertical offset applied to the hint rectangle</short>
      </element>
      <element name="THintWindow.OffsetHintRect.KeepWidth">
        <short>Indicates the width for the hint rectanlge must be maintained</short>
      </element>
      <element name="THintWindow.OffsetHintRect.KeepHeight">
        <short>Indicates the height for the hint rectanlge must be maintained</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.InitializeWnd" link="#LCL.Controls.TControl.InitializeWnd"/>
      <element name="THintWindow.IsHintMsg">
        <short>Indicates if the specified message is relevant to a hint window display</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindow.IsHintMsg.Result">
        <short></short>
      </element>
      <element name="THintWindow.IsHintMsg.Msg">
        <short></short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.ReleaseHandle">
        <short>Destroys an allocated handle for the widget</short>
        <seealso>
          <link id="#LCL.Controls.TWinControl.DestroyHandle"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="THintWindow.SetBounds" link="#LCL.Controls.TControl.InitializeWnd"/>
      <element name="THintWindow.SetBounds.ALeft">
        <short/>
      </element>
      <element name="THintWindow.SetBounds.ATop">
        <short/>
      </element>
      <element name="THintWindow.SetBounds.AWidth">
        <short/>
      </element>
      <element name="THintWindow.SetBounds.AHeight">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="THintWindow.GetControlClassDefaultSize" link="#LCL.Controls.TControl.GetControlClassDefaultSize"/>
      <element name="THintWindow.GetControlClassDefaultSize.Result">
        <short/>
      </element>
      <element name="THintWindow.OnMouseDown" link="#LCL.Controls.TControl.OnMouseDown"/>
      <element name="THintWindow.OnMouseUp" link="#LCL.Controls.TControl.OnMouseUp"/>
      <element name="THintWindow.OnMouseMove" link="#LCL.Controls.TControl.OnMouseMove"/>
      <element name="THintWindow.OnMouseLeave" link="#LCL.Controls.TControl.OnMouseLeave"/>
      <!-- property Visibility: public -->
      <element name="THintWindow.Alignment">
        <short>Text alignment used for the hint window</short>
        <descr>
          <p>
            <var>Alignment</var> is a <var>TAlignment</var> property that indicates the alignment used for the text displayed in the hint window.
          </p>
          <p>
            The default value for the property is <var>taLeftJustify</var>, as assigned in the <var>Create</var> constructor. The value in Alignment is used to derive the draw text flags required for the <var>BidiMode</var> in the hint display, and passed to to <var>DrawText</var> routine in theme services or widget set classes.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.BiDiMode"/>
          <link id="TAlignment"/>
        </seealso>
      </element>
      <element name="THintWindow.HintRect">
        <short>Contains the bounds used to display the text for the hint</short>
        <descr>
          <p>
            <var>HintRect</var> is a <var>TRect</var> property which contains the bounds used to display the hint when it is activated. <var>HintRect</var> is adjusted using the values in <var>HintRectAdjust</var> (when assigned) and the borders drawn around the hint display.
          </p>
        </descr>
        <seealso>
          <link id="THintWindow.ActivateHint"/>
          <link id="THintWindow.ActivateHintData"/>
          <link id="THintWindow.ActivateWithBounds"/>
          <link id="THintWindow.HintRectAdjust"/>
        </seealso>
      </element>
      <element name="THintWindow.HintRectAdjust">
        <short>Contains the bounds with additional space used for the hint display</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindow.HintData">
        <short>Pointer to data used to formulate text displayed in the hint window</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="THintWindow.AutoHide">
        <short>Does the hint disappear (get hidden) after a while?</short>
        <descr>
          If <var>AutoHide</var> is TRUE, the hint disappears after an interval specified by
          <link id="THintWindow.HideInterval">HideInterval</link>.
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="THintWindow.BiDiMode" link="#LCL.Controls.TControl.BiDiMode"/>
      <!-- property Visibility: public -->
      <element name="THintWindow.HideInterval">
        <short>The time after which the displayed hint disappears</short>
        <descr/>
        <seealso>
          <link id="THintWindow.AutoHide"/>
        </seealso>
      </element>
      <!-- "class of" type Visibility: default -->
      <element name="THintWindowClass" link="THintWindow">
        <short>Class of <var>THintWindow</var></short>
        <descr/>
        <seealso/>
      </element>
      <element name="THintWindowRendered">
        <short>For a rendered hint with a child control added by an external provider</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindowRendered.Create">
        <short>Constructor for the class instance</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindowRendered.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <element name="THintWindowRendered.Destroy">
        <short>Destructor for the class instance</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="THintWindowRendered.ActivateRendered">
        <short>Shows hint contents are rendered by a provider on child control</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- object Visibility: default -->
      <element name="TMonitor">
        <short>Provides information about a physical monitor</short>
        <descr>
          <p>
            Monitor information is retrieved dynamically from the Operating System, so that all changes are taken into account. <var>TMonitor</var> has properties that reflect its dimensions, use as the primary monitor, and its display density (or Pixels per Inch).
          </p>
          <p>
            <var>TMonitor</var> is the type returned when reading the <var>TScreen.Monitors</var> property. <var>TMonitor</var> is the type used to implement the <var>TCustomForm.Monitor</var> property.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Monitor"/>
          <link id="TScreen.Monitors"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TMonitor.FHandle" link="TMonitor.Handle"/>
      <element name="TMonitor.FMonitorNum" link="TMonitor.MonitorNum"/>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetInfo">
        <short>Retrieves monitor information from the OS or platform</short>
        <descr>
          <p>
            <var>Getinfo</var> is a <var>Boolean</var> function used to get monitor information from the OS or platform hosting the LCL application. <var>Getinfo</var> initializes the <var>Info</var> output parameter to the size required for the <var>TMonitorInfo</var> type, and calls the <var>GetMonitorInfo</var> routine for the widget set.
          </p>
          <p>
            The return value is <b>True</b> when monitor information is successfully retrieved for the OS or platform. <var>Info</var> contains the size, display rectangle, work area, and flags for the monitor.
          </p>
        </descr>
        <seealso>
          <link id="#LCL.LCLType.TMonitorInfo"/>
        </seealso>
      </element>
      <element name="TMonitor.GetInfo.Result">
        <short>True when monitor information was successfully retrieved</short>
      </element>
      <element name="TMonitor.GetInfo.Info">
        <short>TMonitorInfo with values retrieved for the OS or platform</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetLeft">
        <short>Gets the value for the Left property</short>
        <descr></descr>
        <seealso>
          <link id="TMonitor.Left"/>
        </seealso>
      </element>
      <element name="TMonitor.GetLeft.Result">
        <short>Value for the property</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetHeight" link="TMonitor.Height"/>
      <element name="TMonitor.GetHeight.Result">
        <short/>
      </element>
      <element name="TMonitor.GetPixelsPerInch">
        <short>Gets the value for the PixelsPerInch property</short>
        <descr/>
        <seealso>
          <link id="TMonitor.PixelsPerInch"/>
        </seealso>
      </element>
      <element name="TMonitor.GetPixelsPerInch.Result">
        <short>Value for the property</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetTop" link="TMonitor.Top"/>
      <element name="TMonitor.GetTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetWidth" link="TMonitor.Width"/>
      <element name="TMonitor.GetWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetBoundsRect" link="TMonitor.BoundsRect"/>
      <element name="TMonitor.GetBoundsRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetWorkareaRect" link="TMonitor.WorkareaRect"/>
      <element name="TMonitor.GetWorkareaRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitor.GetPrimary" link="TMonitor.Primary"/>
      <element name="TMonitor.GetPrimary.Result">
        <short/>
      </element>
      <element name="TMonitor.Handle">
        <short>Handle which identifies this monitor to the system</short>
      </element>
      <element name="TMonitor.MonitorNum">
        <short>Index of the monitor in the <link id="TScreen.Monitors"/> list</short>
      </element>
      <element name="TMonitor.Left">
        <short>The leftmost screen coordinate of the display</short>
      </element>
      <element name="TMonitor.Height">
        <short>The height of the display</short>
      </element>
      <element name="TMonitor.Top">
        <short>The topmost screen coordinate of the display</short>
      </element>
      <element name="TMonitor.Width">
        <short>The width of the display</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TMonitor.BoundsRect">
        <short>The logical dimensions of the monitor, within the desktop.
        </short>
      </element>
      <element name="TMonitor.WorkareaRect">
        <short>The usable display area, excluding a taskbar etc</short>
      </element>
      <element name="TMonitor.Primary">
        <short>True if this is the primary monitor of the system</short>
      </element>
      <element name="TMonitor.PixelsPerInch">
        <short>Contains the Pixels Per Inch or display density for the monitor</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TMonitorList">
        <short>A list of all available monitors</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TMonitorList.GetItem" link="TMonitorList.Items"/>
      <element name="TMonitorList.GetItem.Result">
        <short/>
      </element>
      <element name="TMonitorList.GetItem.AIndex">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TMonitorList.SetItem" link="TMonitorList.Items"/>
      <element name="TMonitorList.SetItem.AIndex">
        <short/>
      </element>
      <element name="TMonitorList.SetItem.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TMonitorList.Notify">
        <short>
          List notification handler, destroys the Monitor object on removal from the list
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TMonitorList.Notify.Ptr">
        <short>The monitor object</short>
      </element>
      <element name="TMonitorList.Notify.Action">
        <short>The list operation</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TMonitorList.Items">
        <short>The indexed list of all Monitors</short>
        <descr>
          Items is the default property for the monitor list.
        </descr>
        <seealso></seealso>
      </element>
      <element name="TMonitorList.Items.AIndex">
        <short>Ordinal position for a monitor in the list</short>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PCursorRec" link="TCursorRec"/>
      <!-- record type Visibility: default -->
      <element name="TCursorRec">
        <short>An element of the Cursor list</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCursorRec.Next">
        <short>The next list element</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCursorRec.Index">
        <short>The list index</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCursorRec.Handle">
        <short>The OS identifier for this cursor</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TScreenFormEvent">
        <short>Type of an screen notification handler, for form related events</short>
        <descr/>
        <seealso>
          <link id="TScreenNotification"/>
          <link id="TScreenControlEvent"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreenFormEvent.Sender">
        <short>TObject for the event notification</short>
        <notes><note>?</note></notes>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreenFormEvent.Form">
        <short>The affected form</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TScreenControlEvent">
        <short>Type for a screen notification handler, for control related events</short>
        <descr/>
        <seealso>
          <link id="TScreenNotification"/>
          <link id="TScreenFormEvent"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreenControlEvent.Sender">
        <short>TObject for the event notification</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreenControlEvent.LastControl">
        <short>The <b>new</b> active control</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TScreenNotification">
        <short>Screen notification events and handler types</short>
        <descr/>
        <seealso>
          <link id="TScreenFormEvent"/>
          <link id="TScreenControlEvent"/>
        </seealso>
      </element>
      <element name="TScreenNotification.snFormAdded">
        <short>A form was added</short>
      </element>
      <element name="TScreenNotification.snRemoveForm">
        <short>A form was removed</short>
      </element>
      <element name="TScreenNotification.snActiveControlChanged">
        <short>The focus moved to another control</short>
      </element>
      <element name="TScreenNotification.snActiveFormChanged">
        <short>The focus moved to another form</short>
      </element>
      <element name="TScreenNotification.snFormVisibleChanged">
        <short>The visibility of a form changed</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TMonitorDefaultTo">
        <short>
          The monitor to use when screen coordinates are outside of the physical screen bounds
        </short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TMonitorDefaultTo.mdNearest">
        <short>Default to the nearest monitor</short>
      </element>
      <element name="TMonitorDefaultTo.mdNull">
        <short>Default to Nil (no suggested monitor)</short>
      </element>
      <element name="TMonitorDefaultTo.mdPrimary">
        <short>Default to the primary monitor</short>
      </element>
      <!-- object Visibility: default -->
      <element name="TScreen">
        <short>Provides information about the display and related objects</short>
        <descr>
          <p>
            The virtual screen (desktop) can include multiple <link id="TScreen.Monitors">physical Monitors</link>. Screen objects are Cursors, Fonts and Forms. For Delphi compatibility, non-visual  DataModules are included.
          </p>
          <p>The currently active Form, Control and Cursor also are tracked.</p>
        </descr>
        <seealso>
          <link id="TScreen.Cursors"/>
          <link id="TScreen.DataModules"/>
          <link id="TScreen.DesktopRect"/>
          <link id="TScreen.Fonts"/>
          <link id="TScreen.Forms"/>
          <link id="TScreen.Monitors"/>
          <link id="TScreen.WorkareaRect"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TScreen.FActiveControl" link="TScreen.ActiveControl"/>
      <element name="TScreen.FActiveCustomForm" link="TScreen.ActiveCustomForm"/>
      <element name="TScreen.FActiveForm" link="TScreen.ActiveForm"/>
      <element name="TScreen.FCursor" link="TScreen.Cursor"/>
      <element name="TScreen.FCursorMap" link="TScreen.Cursors"/>
      <element name="TScreen.FCustomForms" link="TScreen.CustomForms"/>
      <element name="TScreen.FCustomFormsZOrdered" link="TScreen.CustomFormsZOrdered"/>
      <element name="TScreen.FDefaultCursor"/>
      <!-- variable Visibility: private -->
      <element name="TScreen.FHintFont" link="TScreen.HintFont"/>
      <element name="TScreen.FFocusedForm" link="TScreen.FocusedForm"/>
      <element name="TScreen.FFonts" link="TScreen.Fonts"/>
      <element name="TScreen.FFormList" link="TScreen.Forms"/>
      <element name="TScreen.FDataModuleList" link="TScreen.DataModules"/>
      <element name="TScreen.FIconFont" link="TScreen.IconFont"/>
      <element name="TScreen.FMenuFont" link="TScreen.MenuFont"/>
      <element name="TScreen.FScreenHandlers"/>
      <element name="TScreen.FLastActiveControl"/>
      <!-- variable Visibility: private -->
      <element name="TScreen.FLastActiveCustomForm">
        <short>The last active form, used to detect focus changes</short>
        <descr/>
        <seealso>
          <link id="TScreen.RestoreLastActive"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TScreen.FMonitors" link="TScreen.Monitors"/>
      <element name="TScreen.FOnActiveControlChange" link="TScreen.OnActiveControlChange"/>
      <element name="TScreen.FOnActiveFormChange" link="TScreen.OnActiveFormChange"/>
      <element name="TScreen.FPixelsPerInch" link="TScreen.PixelsPerInch"/>
      <!-- variable Visibility: private -->
      <element name="TScreen.FSaveFocusedList"/>
      <!-- variable Visibility: private -->
      <element name="TScreen.FSystemFont" link="TScreen.SystemFont"/>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DeleteCursor">
        <short>Removes a cursor from the Cursors property</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.DeleteCursor.AIndex">
        <short>The logical cursor ID</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DestroyCursors">
        <short>Deletes all TCursor instances in the Cursors property</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DestroyMonitors">
        <short>Clears the Monitors list</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCursors" link="TScreen.Cursors"/>
      <element name="TScreen.GetCursors.Result">
        <short/>
      </element>
      <element name="TScreen.GetCursors.AIndex">
        <short>The logical cursor ID</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCustomFormCount" link="TScreen.CustomFormCount"/>
      <element name="TScreen.GetCustomFormCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCustomFormZOrderCount" link="TScreen.CustomFormZOrderCount"/>
      <element name="TScreen.GetCustomFormZOrderCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCustomForms" link="TScreen.CustomForms"/>
      <element name="TScreen.GetCustomForms.Result">
        <short/>
      </element>
      <element name="TScreen.GetCustomForms.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetCustomFormsZOrdered" link="TScreen.CustomFormZOrdered"/>
      <element name="TScreen.GetCustomFormsZOrdered.Result">
        <short/>
      </element>
      <element name="TScreen.GetCustomFormsZOrdered.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDataModuleCount" link="TScreen.DataModuleCount"/>
      <element name="TScreen.GetDataModuleCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDataModules" link="TScreen.DataModules"/>
      <element name="TScreen.GetDataModules.Result">
        <short/>
      </element>
      <element name="TScreen.GetDataModules.AIndex">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopLeft" link="TScreen.DesktopLeft"/>
      <element name="TScreen.GetDesktopLeft.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopTop" link="TScreen.DesktopTop"/>
      <element name="TScreen.GetDesktopTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopHeight" link="TScreen.DesktopHeight"/>
      <element name="TScreen.GetDesktopHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopWidth" link="TScreen.DesktopWidth"/>
      <element name="TScreen.GetDesktopWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetDesktopRect" link="TScreen.DesktopRect"/>
      <element name="TScreen.GetDesktopRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetFonts" link="TScreen.Fonts"/>
      <element name="TScreen.GetFonts.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetFormCount" link="TScreen.FormCount"/>
      <element name="TScreen.GetFormCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetForms" link="TScreen.Forms"/>
      <element name="TScreen.GetForms.Result">
        <short/>
      </element>
      <element name="TScreen.GetForms.IIndex">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetHeight" link="TScreen.Height"/>
      <element name="TScreen.GetHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetMonitor" link="TScreen.Monitors"/>
      <element name="TScreen.GetMonitor.Result">
      <short/>
      </element>
      <element name="TScreen.GetMonitor.Index">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetMonitorCount" link="TScreen.MonitorCount"/>
      <element name="TScreen.GetMonitorCount.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetPrimaryMonitor" link="TScreen.PrimaryMonitor"/>
      <element name="TScreen.GetPrimaryMonitor.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWidth" link="TScreen.Width"/>
      <element name="TScreen.GetWidth.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.AddForm">
        <short>Internal notification handler, adds a new form to the lists</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddForm.AForm">
        <short>Form instance added in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.RemoveForm">
        <short>Internal notification handler, removes the form from the lists</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveForm.AForm">
        <short>Form instance removed from the list</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.SetFocusedForm" link="TScreen.FocusedForm"/>
      <element name="TScreen.SetFocusedForm.Result">
        <short/>
      </element>
      <element name="TScreen.SetFocusedForm.AForm">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetCursor" link="TScreen.Cursor"/>
      <element name="TScreen.SetCursor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetCursors" link="TScreen.Cursors"/>
      <element name="TScreen.SetCursors.AIndex">
        <short/>
      </element>
      <element name="TScreen.SetCursors.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetHintFont" link="TScreen.HintFont"/>
      <element name="TScreen.SetHintFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetIconFont" link="TScreen.IconFont"/>
      <element name="TScreen.SetIconFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetMenuFont" link="TScreen.MenuFont"/>
      <element name="TScreen.SetMenuFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.SetSystemFont" link="TScreen.SystemFont"/>
      <element name="TScreen.SetSystemFont.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.UpdateLastActive">
        <short>Stores the currently active form and control in the last active members.
          Notifies all registered handlers of eventual changes.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.RestoreLastActive">
        <short>Moves the Focus back to the previously focused control</short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.AddHandler">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandler.HandlerType">
        <short>The notification (event) type</short>
      </element>
      <element name="TScreen.AddHandler.Handler">
        <short>The notification handler</short>
      </element>
      <element name="TScreen.AddHandler.AsFirst">
        <short>Add the handler as the first (True) or last (False) handler</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.RemoveHandler">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandler.HandlerType">
        <short>The notification (event) type</short>
      </element>
      <element name="TScreen.RemoveHandler.Handler">
        <short>The notification handler</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DoAddDataModule" link="TScreen.DataModules">
        <short>Adds the specified DataModule to the list</short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
      </element>
      <element name="TScreen.DoAddDataModule.DataModule">
        <short>Data module instance added in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.DoRemoveDataModule" link="TScreen.DataModules">
        <short>Removes the specified DataModule from the list</short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
      </element>
      <element name="TScreen.DoRemoveDataModule.DataModule">
        <short>Data module removed in the method</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.NotifyScreenFormHandler">
        <short>Notifies all registered handlers for the given event</short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
      </element>
      <element name="TScreen.NotifyScreenFormHandler.HandlerType">
        <short>Event type for the notification</short>
      </element>
      <element name="TScreen.NotifyScreenFormHandler.Form">
        <short>Form instance for the notification</short>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaHeight" link="TScreen.WorkAreaHeight"/>
      <element name="TScreen.GetWorkAreaHeight.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaLeft" link="TScreen.WorkAreaLeft"/>
      <element name="TScreen.GetWorkAreaLeft.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaRect" link="TScreen.WorkAreaRect"/>
      <element name="TScreen.GetWorkAreaRect.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaTop" link="TScreen.WorkAreaTop"/>
      <element name="TScreen.GetWorkAreaTop.Result">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TScreen.GetWorkAreaWidth" link="TScreen.WorkAreaWidth"/>
      <element name="TScreen.GetWorkAreaWidth.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScreen.GetHintFont" link="TScreen.HintFont"/>
      <element name="TScreen.GetHintFont.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScreen.GetIconFont" link="TScreen.IconFont"/>
      <element name="TScreen.GetIconFont.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScreen.GetMenuFont" link="TScreen.MenuFont"/>
      <element name="TScreen.GetMenuFont.Result">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TScreen.GetSystemFont" link="TScreen.SystemFont"/>
      <element name="TScreen.GetSystemFont.Result">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TScreen.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TScreen.Create.AOwner">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TScreen.Destroy"/>
      <!-- function Visibility: public -->
      <element name="TScreen.CustomFormIndex" link="TScreen.CustomForms">
        <short>The ordinal position in CustomForms the requested form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.CustomFormIndex.Result">
        <short>The form Index, -1 if not found</short>
      </element>
      <element name="TScreen.CustomFormIndex.AForm">
        <short>The Form to which the Index refers</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.FormIndex">
        <short>The ordinal position in Forms for the requested form</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.FormIndex.Result">
        <short>The form Index, -1 if not found</short>
      </element>
      <element name="TScreen.FormIndex.AForm">
        <short>The Form to which the Index refers</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.CustomFormZIndex">
        <short>The index of the form  in the Z dimension (Front to Back)</short>
        <descr>
          <p>
            The return value contains the activation order for the specified form, with the currently active form at index position zero (<b>0</b>).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TScreen.CustomFormZIndex.Result">
        <short/>
      </element>
      <element name="TScreen.CustomFormZIndex.AForm">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.MoveFormToFocusFront">
        <short>Moves the specified form to the front of all form lists</short>
        <descr/>
        <errors>
          Raises a GDB exception when the form is being destroyed, or the application is shutting down.
        </errors>
        <seealso/>
      </element>
      <element name="TScreen.MoveFormToFocusFront.ACustomForm">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.MoveFormToZFront">
        <short>Moves the form to the front of the Z-order list (notification only)</short>
        <descr/>
        <errors>
          Raises a GDB exception when the form is being destroyed, or the application is shutting down.
        </errors>
        <seealso>
          <link id="TScreen.MoveFormToFocusFront"/>
        </seealso>
      </element>
      <element name="TScreen.MoveFormToZFront.ACustomForm">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.GetCurrentModalForm">
        <short>
          Returns the topmost Modal form (i.e. a form that is awaiting a user response).
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.GetCurrentModalForm.Result">
        <short>The modal form, or Nil if none is active</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.GetCurrentModalFormZIndex">
        <short>Returns the index of the topmost modal form in CustomFormsZOrdered[]</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.GetCurrentModalFormZIndex.Result">
        <short>The index for the form, or -1 if no modal form is active</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.CustomFormBelongsToActiveGroup">
        <short>Checks whether the form is visible, and whether modal or not blocked by
          another modal form</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TScreen.CustomFormBelongsToActiveGroup.Result">
        <short/>
      </element>
      <element name="TScreen.CustomFormBelongsToActiveGroup.AForm">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.FindNonDesignerForm">
        <short>Finds the named form, excluding designer forms</short>
        <descr></descr>
        <seealso>
          <link id="TScreen.FindForm"/>
        </seealso>
      </element>
      <element name="TScreen.FindNonDesignerForm.Result">
        <short/>
      </element>
      <element name="TScreen.FindNonDesignerForm.FormName">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.FindForm">
        <short>Finds a form by its name</short>
        <descr/>
        <seealso>
          <link id="TScreen.FindNonDesignerForm"/>
        </seealso>
      </element>
      <element name="TScreen.FindForm.Result">
        <short/>
      </element>
      <element name="TScreen.FindForm.FormName">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.FindNonDesignerDataModule">
        <short>Finds the named DataModule, excluding designer modules</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreen.FindDataModule"/>
        </seealso>
      </element>
      <element name="TScreen.FindNonDesignerDataModule.Result">
        <short/>
      </element>
      <element name="TScreen.FindNonDesignerDataModule.DataModuleName">
        <short/>
      </element>
      <element name="TScreen.FindDataModule.Result">
        <short/>
      </element>
      <element name="TScreen.FindDataModule.DataModuleName">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.FindDataModule">
        <short>Finds the named DataModule</short>
        <seealso>
          <link id="TScreen.FindNonDesignerDataModule"/>
        </seealso>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TScreen.UpdateMonitors">
        <short>Builds the list of available monitors</short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.UpdateScreen">
        <short>Updates the <link id="TScreen.PixelsPerInch"/> property</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveAllHandlersOfObject" link="#LCL.LCLClasses.TLCLComponent.RemoveAllHandlersOfObject"/>
      <element name="TScreen.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerFormAdded">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerFormAdded.OnFormAdded">
        <short/>
      </element>
      <element name="TScreen.AddHandlerFormAdded.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerFormAdded">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerFormAdded.OnFormAdded">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerRemoveForm">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerRemoveForm.OnRemoveForm">
        <short/>
      </element>
      <element name="TScreen.AddHandlerRemoveForm.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerRemoveForm">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerRemoveForm.OnRemoveForm">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerActiveControlChanged">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerActiveControlChanged.OnActiveControlChanged">
        <short/>
      </element>
      <element name="TScreen.AddHandlerActiveControlChanged.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerActiveControlChanged">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerActiveControlChanged.OnActiveControlChanged">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerActiveFormChanged">
        <short>Adds a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.AddHandlerActiveFormChanged.OnActiveFormChanged">
        <short/>
      </element>
      <element name="TScreen.AddHandlerActiveFormChanged.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerActiveFormChanged">
        <short>Removes a notification handler</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TScreen.RemoveHandlerActiveFormChanged.OnActiveFormChanged">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.AddHandlerFormVisibleChanged">
        <short>Adds a notification handler</short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
      </element>
      <element name="TScreen.AddHandlerFormVisibleChanged.OnFormVisibleChanged">
        <short/>
      </element>
      <element name="TScreen.AddHandlerFormVisibleChanged.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.RemoveHandlerFormVisibleChanged">
        <short>Removes a notification handler</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TScreen.RemoveHandlerFormVisibleChanged.OnFormVisibleChanged">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.DisableForms">
        <short>Disable all forms except <var>SkipForm</var>.
        </short>
        <descr>
          <p>Used to show modal forms or dialogs.</p>
          <p>The enabled state is determined from the widget, not from LCL properties.</p>
          <p>If <var>DisabledList</var> is Nil, a new list is created. Then all disabled forms
           are added to that list.</p>
           <p>When the modal form returns, call EnableForms to restore all forms.</p>
        </descr>
        <seealso>
          <link id="TScreen.EnableForms"/>
        </seealso>
      </element>
      <element name="TScreen.DisableForms.Result">
        <short>The list containing all disabled forms</short>
      </element>
      <element name="TScreen.DisableForms.SkipForm">
        <short>Don't disable this form (ignored if Nil)</short>
      </element>
      <element name="TScreen.DisableForms.DisabledList">
        <short>The list to update. If Nil, a new list is created and returned</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TScreen.EnableForms">
        <short>Use this method to restore all
          <link id="TScreen.DisableForms">previously disabled</link> forms.
        </short>
        <seealso>
          <link id="TScreen.DisableForms"/>
        </seealso>
      </element>
      <element name="TScreen.EnableForms.AFormList">
        <short>The list containing the forms to enable. The list is destroyed on exit.</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.MonitorFromPoint">
          <short>Find the monitor containing the given screen coordinates</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreen.MonitorFromRect"/>
        </seealso>
      </element>
      <element name="TScreen.MonitorFromPoint.Result">
        <short>The monitor found</short>
      </element>
      <element name="TScreen.MonitorFromPoint.Point">
        <short>The screen coordinates to find</short>
      </element>
      <element name="TScreen.MonitorFromPoint.MonitorDefault">
        <short>What to return when no monitor was found</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.MonitorFromRect">
        <short>Find the monitor containing (most of) the given screen coordinates</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreen.MonitorFromPoint"/>
        </seealso>
      </element>
      <element name="TScreen.MonitorFromRect.Result">
        <short>The monitor found</short>
      </element>
      <element name="TScreen.MonitorFromRect.Rect">
        <short>The screen coordinates to find</short>
      </element>
      <element name="TScreen.MonitorFromRect.MonitorDefault">
        <short>What to return when no monitor was found</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TScreen.MonitorFromWindow">
        <short>Finds the monitor containing (most of) the given window handle</short>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
      </element>
      <element name="TScreen.MonitorFromWindow.Result">
        <short>The monitor found</short>
      </element>
      <element name="TScreen.MonitorFromWindow.Handle">
        <short>The window handle to use</short>
      </element>
      <element name="TScreen.MonitorFromWindow.MonitorDefault">
        <short>What to return when no monitor was found</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.ActiveControl">
        <short>The control which has the Focus for the screen</short>
        <descr/>
        <seealso>
          <link id="TScreen.ActiveForm"/>
          <link id="TScreen.ActiveCustomForm"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.ActiveCustomForm">
        <short>The custom form which has the Focus</short>
        <seealso>
          <link id="TScreen.ActiveForm"/>
          <link id="TScreen.ActiveControl"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.ActiveForm">
        <short>The form which has the Focus</short>
        <seealso>
          <link id="TScreen.ActiveControl"/>
          <link id="TScreen.ActiveCustomForm"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Cursor">
        <short>The current mouse cursor shape</short>
        <descr>Use one of the predefined cursor styles, e.g. crHourGlass.</descr>
        <seealso>
          <link id="Controls.crDefault"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Cursors">
        <short>Provides indexed access to the available cursor shapes for the screen</short>
      </element>
      <!-- argument Visibility: default -->
      <element name="TScreen.Cursors.Index">
        <short>Ordinal position for the value requested</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.CustomFormCount">
        <short>The number of Custom Forms</short>
        <seealso>
          <link id="TScreen.CustomForms"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.CustomForms">
        <short>Provides indexed access to the list of Custom Forms for the screen</short>
        <descr/>
        <seealso>
          <link id="TScreen.CustomFormCount"/>
        </seealso>
      </element>
      <element name="TScreen.CustomForms.Index">
        <short>Ordinal position for the requested form</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.CustomFormsZOrdered">
        <short>The list of Custom Forms, indexed by Z-order (zero is topmost)</short>
        <descr/>
        <seealso>
          <link id="TScreen.CustomFormZOrderCount"/>
        </seealso>
      </element>
      <element name="TScreen.CustomFormsZOrdered.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.CustomFormZOrderCount">
        <short>
          <var>CustomFormZOrderCount</var> - the number of forms arranged in Z-plane order (i.e. Front to Back)
        </short>
        <descr/>
        <seealso>
          <link id="TScreen.CustomFormsZOrdered"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopLeft" link="TScreen.DesktopRect">
        <short>The leftmost coordinate of the desktop</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopTop" link="TScreen.DesktopRect">
        <short>The topmost coordinate of the desktop</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopHeight" link="TScreen.DesktopRect">
        <short>The total vertical size of the desktop</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopWidth" link="TScreen.DesktopRect">
        <short>The total horizontal size of the display.
        </short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DesktopRect">
        <short>The total extent of the desktop, spanning all monitors</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.FocusedForm">
        <short>The form that holds Focus</short>
        <descr></descr>
        <seealso>
          <link id="TScreen.ActiveForm"/>
          <link id="TScreen.ActiveCustomForm"/>
        </seealso>
        <notes><note>really?</note><note>what's different from ActiveForm?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.FormCount" link="TScreen.Forms">
        <short>The number of existing Forms</short>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Forms">
        <short>The indexed list of all Forms, in Z-order</short>
        <descr/>
        <seealso>
          <link id="TScreen.FormCount"/>
          <link id="TScreen.CustomForms"/>
        </seealso>
      </element>
      <element name="TScreen.Forms.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DataModuleCount">
        <short>The number of existing data modules</short>
        <seealso>
          <link id="TScreen.DataModules"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.DataModules">
        <short>The indexed list of Data Modules</short>
        <seealso>
          <link id="TScreen.DataModuleCount"/>
        </seealso>
      </element>
      <element name="TScreen.DataModules.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.HintFont">
        <short>The font used to display Hints</short>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.IconFont">
        <short>The Icon font, used with desktop icons</short>
        <descr></descr>
        <seealso></seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.MenuFont">
        <short>The font used in menus</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.SystemFont">
        <short>
          The default font used for system task dialogs and controls like TSpeedButton
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Fonts">
        <short>The names of the available (installed) fonts</short>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Height">
        <short>The height of the primary monitor</short>
        <seealso>
          <link id="TScreen.PrimaryMonitor"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.MonitorCount" link="TScreen.Monitors">
        <short>The number of available Monitors</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Monitors">
        <short>The indexed list of available monitors.
        </short>
        <seealso>
          <link id="TScreen.MonitorCount"/>
        </seealso>
      </element>
      <element name="TScreen.Monitors.Index">
        <short/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.PixelsPerInch">
        <short>
          The number of screen pixels for an virtual inch (DPI), in the vertical direction.
        </short>
        <descr>
          <p>
            The display uses virtual inches, which typically are bigger than physical inches. This requires that text appear bigger on a screen than on a printer.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.PrimaryMonitor">
        <short>The primary monitor typically shows the taskbar.
        </short>
        <seealso>
          <link id="TScreen.WorkareaRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.Width">
        <short>The width of the primary monitor</short>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaRect">
        <short>The usable display area on the primary monitor, excluding e.g. the taskbar</short>
        <descr>
        </descr>
        <seealso>
          <link id="TScreen.DesktopRect"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaHeight" link="TScreen.WorkareaRect">
        <short>The usable height of the primary monitor</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaLeft" link="TScreen.WorkareaRect">
        <short>The usable left coordinate on the primary monitor</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaTop" link="TScreen.WorkareaRect">
        <short>The usable top coordinate on the primary monitor</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.WorkAreaWidth" link="TScreen.WorkareaRect">
        <short>The usable width of the primary monitor</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.OnActiveControlChange">
        <short>Handler for a Focus changed notification</short>
        <descr/>
        <seealso>
          <link id="TScreen.AddHandlerActiveControlChanged"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TScreen.OnActiveFormChange">
        <short>Handler for a Focus changed notification</short>
        <descr/>
        <seealso>
          <link id="TScreen.AddHandlerActiveFormChanged"/>
        </seealso>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TQueryEndSessionEvent">
        <short>The type of an <link id="TApplication.OnQueryEndSession"/> handler.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TQueryEndSessionEvent.Cancel">
        <short>Set Cancel to True to prevent a logoff</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TExceptionEvent">
        <short>
          Defines an event handler signalled to perform exception handling in applications
        </short>
        <descr>
          <p>
            <var>TExceptionEvent</var> is an object procedure type that defines an event handler signalled to perform exception handling in an application. Arguments passed to the event handler identify the application generating the notification, and the exception class instance. Applications must implement an object procedure using the signature for the event, and assign it to an event handler to respond to the notification.
          </p>
          <p>
            <var>TExceptionEvent</var> is the type used to implement exception handlers in <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.HandleException"/>
          <link id="TApplicationProperties.OnException"/>
        </seealso>
      </element>
      <element name="TExceptionEvent.Sender">
        <short>Object instance for the notification</short>
      </element>
      <element name="TExceptionEvent.E">
        <short>Exception instance for the notification</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TGetHandleEvent">
        <short>
          Specifies an event handler used to get the handle for the main form in an application
        </short>
        <descr>
          <p>
            <var>TGetHandleEvent</var> is an object procedure type which defines an event handler signalled to get the handle for the main form in an application. <var>TGetHandleEvent</var> is the type used to implement the <var>OnGetMainFormHandle</var> event handler in <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.OnGetMainFormHandle"/>
          <link id="TApplicationProperties.OnGetMainFormHandle"/>
          <link id="TApplication.AddOnGetMainFormHandleHandler"/>
          <link id="TApplication.RemoveOnGetMainFormHandleHandler"/>
        </seealso>
      </element>
      <element name="TGetHandleEvent.Handle">
        <short>Handle for the form instance used as the main form</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TIdleEvent">
        <short>Type of an Idle event handler</short>
        <descr>
          <p>
            Lengthy operations should be broken into smaller parts, to ensure that the application remains responsive. The handlers are called repeatedly, until all signal Done.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TIdleEvent.Sender">
        <short/>
      </element>
      <element name="TIdleEvent.Done">
        <short>Set to True when everything is done</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TOnUserInputEvent">
        <short>
          Specifies an event handler signalled to respond to user input messages in an application
        </short>
        <descr>
          <p>
            <var>TOnUserInputEvent</var> is an object procedure type which defines an event handler signalled to respond to user input messages in an application. It is used as a callback which forwards input messages from widget set classes to the current application.
          </p>
          <p>
            <var>TOnUserInputEvent</var> is the type used for the <var>OnUserInput</var> event handler in <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.OnUserInput"/>
          <link id="TApplicationProperties.OnUserInput"/>
          <link id="TApplication.AddOnUserInputHandler"/>
          <link id="TApplication.RemoveOnUserInputHandler"/>
        </seealso>
      </element>
      <element name="TOnUserInputEvent.Sender">
        <short/>
      </element>
      <element name="TOnUserInputEvent.Msg">
        <short/>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TDataEvent">
        <short>The type of an asynchronous callback method</short>
        <descr/>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
        </seealso>
      </element>
      <element name="TDataEvent.Data">
        <short>The argument passed to the method</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMHintShow">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShow.Msg">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShow.Reserved">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShow.HintInfo">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShow.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TCMHintShowPause">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShowPause.Msg">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShowPause.WasActive">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShowPause.Pause">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="TCMHintShowPause.Result">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TAppHintTimerType">
        <short>The TApplication hint timer state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TAppHintTimerType.ahttNone">
        <short>The hint timer is off</short>
      </element>
      <element name="TAppHintTimerType.ahttShowHint">
        <short>Waiting to show a hint; used when a hint timer is started</short>
      </element>
      <element name="TAppHintTimerType.ahttHideHint">
        <short>Waiting to hide an hint; used when the hint control is changed or the mouse leaevs a hint rectangle</short>
      </element>
      <element name="TAppHintTimerType.ahttReshowHint">
        <short>Waiting to show the next hint; used when the hide hint timer is started</short>
      </element>
      <!-- procedure type Visibility: default -->
      <element name="TShowHintEvent">
        <short>Defines an event handler signalled to perform hint display</short>
        <descr>
          <p>
            <var>TShowHintEvent</var> is an object procedure type which defines an event handler signalled to perform hint display. It is the type used for the <var>TApplication.OnShowHint</var> event handler property.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.OnShowHint"/>
          <link id="TApplication.ShowHintWindow"/>
          <link id="TApplication.AddOnShowHintHandler"/>
          <link id="TApplication.RemoveOnShowHintHandler"/>
          <link id="TApplicationProperties.OnShowHint"/>
        </seealso>
      </element>
      <element name="TShowHintEvent.HintStr">
        <short/>
      </element>
      <element name="TShowHintEvent.CanShow">
        <short/>
      </element>
      <element name="TShowHintEvent.HintInfo">
        <short/>
      </element>
      <!-- record type Visibility: default -->
      <element name="THintInfoAtMouse">
        <short>
          Stores control and mouse position information for a hint display
        </short>
        <descr>
          <p>
            <var>THintInfoAtMouse</var> is a record type used to store Control and Mouse position information for a hint display.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ShowHintWindow"/>
          <link id="TApplication.ActivateHint"/>
          <link id="TApplication.OnHintTimer"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="THintInfoAtMouse.MousePos">
        <short/>
      </element>
      <element name="THintInfoAtMouse.Control">
        <short/>
      </element>
      <element name="THintInfoAtMouse.ControlHasHint">
        <short/>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationFlag">
        <short>Application state flags</short>
        <descr>
          <p>
            <var>TApplicationFlag</var> is an enumeration type with values that represent activity or state in an application. <var>TApplicationFlag</var> values are stored in the <var>TApplicationFlags</var> type used to implement the <var>Flags</var> property in <var>TApplication</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplicationFlags"/>
          <link id="TApplication.Flags"/>
        </seealso>
      </element>
      <element name="TApplicationFlag.AppWaiting">
        <short>Application is in an Idle state and waiting for a message</short>
      </element>
      <element name="TApplicationFlag.AppIdleEndSent">
        <short>
          IdleEnd handlers have been notified of message arrival; end the idle state for the application
        </short>
      </element>
      <element name="TApplicationFlag.AppHandlingException">
        <short>In exception handling</short>
        <notes><note>Not used in the current LCL version.</note></notes>
      </element>
      <element name="TApplicationFlag.AppNoExceptionMessages">
        <short>
          Suppresses exception display for the application; set when an exception is aborted in the application
        </short>
      </element>
      <element name="TApplicationFlag.AppActive">
        <short>The application has focus; prevents recursive application activation</short>
      </element>
      <element name="TApplicationFlag.AppDestroying">
        <short>Shutting down; set when the application instance is freed</short>
      </element>
      <element name="TApplicationFlag.AppDoNotCallAsyncQueue">
        <short>Skip asynchronous callbacks between handling messages</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationFlag.AppInitialized">
        <short>Application has been initialized</short>
      </element>
      <!-- set type Visibility: default -->
      <element name="TApplicationFlags" link="TApplicationFlag"/>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationNavigationOption">
        <short>Which keys can be used for the navigation within a form</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationNavigationOption.anoTabToSelectNext">
        <short>The Tab key moves the Focus to the next (or previous) control in TabOrder.
        </short>
      </element>
      <element name="TApplicationNavigationOption.anoReturnForDefaultControl">
        <short>The Enter key triggers the default action.
        </short>
      </element>
      <element name="TApplicationNavigationOption.anoEscapeForCancelControl">
        <short>The Escape key triggers the Cancel action</short>
      </element>
      <element name="TApplicationNavigationOption.anoF1ForHelp">
        <short>The F1 key brings up context sensitive help</short>
      </element>
      <element name="TApplicationNavigationOption.anoArrowToSelectNextInParent">
        <short>The Arrow keys move the focus</short>
        <notes><note>?</note></notes>
      </element>
      <!-- set type Visibility: default -->
      <element name="TApplicationNavigationOptions" link="TApplicationNavigationOption"/>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationHandlerType">
        <short>Types of Application notification handlers</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplicationHandlerType.ahtIdle">
        <short>Application becoming idle</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtIdleEnd">
        <short>Application becoming busy</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtKeyDownBefore">
        <short>Handler for KeyDown events, invoked before interface and LCL handlers</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtKeyDownAfter">
        <short>Default handler for KeyDown events, invoked after interface
          and LCL handlers</short>
          <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtActivate">
        <short>Handler invoked on application activated</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtDeactivate">
        <short>Handler invoked on application deactivated</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtUserInput">
        <short>Handler invoked on user input</short>
        <notes><note>what's this?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtException">
        <short>Handler invoked on handled exception</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtEndSession">
        <short>Handler invoked on session end</short>
        <notes><note>what's this?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtQueryEndSession">
        <short>Handler invoked before session ends</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtMinimize">
        <short>Handler invoked when the application is minimized</short>
      </element>
      <element name="TApplicationHandlerType.ahtModalBegin">
        <short>Handler invoked when a form is shown modally</short>
      </element>
      <element name="TApplicationHandlerType.ahtModalEnd">
        <short>Handler invoked when the last modal form is closed</short>
      </element>
      <element name="TApplicationHandlerType.ahtRestore">
        <short>Handler invoked on application restored (from minimized state)</short>
      </element>
      <element name="TApplicationHandlerType.ahtDropFiles">
        <short>Handler invoked on files dropped</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtHelp">
        <short>Handler invoked on F1 key (help request)</short>
        <notes><note>purpose?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtHint">
        <short>Handler invoked on Hint request</short>
        <notes><note>purpose?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtShowHint">
        <short>Handler invoked on Hint becoming visible</short>
        <notes><note>purpose?</note></notes>
      </element>
      <element name="TApplicationHandlerType.ahtGetMainFormHandle">
        <short>Handler provides the Handle for the main form</short>
        <descr></descr>
        <notes>
          <note>?</note>
          <note>application/taskbar window?</note>
          <note>purpose?</note>
          <note>what's the purpose for *not* returning MainForm.Handle???</note>
        </notes>
      </element>
      <!-- pointer type Visibility: default -->
      <element name="PAsyncCallQueueItem" link="TAsyncCallQueueItem">
        <short>A queued asynchronous callback request node</short>
        <descr/>
        <seealso/>
      </element>
      <!-- record type Visibility: default -->
      <element name="TAsyncCallQueueItem">
        <short>A queued asynchronous callback request node</short>
        <descr/>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
        </seealso>
      </element>
      <element name="TAsyncCallQueueItem.Method">
        <short>The callback method</short>
        <descr/>
      </element>
      <element name="TAsyncCallQueueItem.Data">
        <short>The method call argument</short>
        <descr/>
      </element>
      <element name="TAsyncCallQueueItem.NextItem">
        <short>The next list node</short>
        <descr/>
      </element>
      <element name="TAsyncCallQueueItem.PrevItem">
        <short>The preceding list node</short>
        <descr>
        </descr>
        <notes><note>superfluous, could be removed?</note></notes>
      </element>
      <!-- record type Visibility: default -->
      <element name="TAsyncCallQueue">
        <short>The queue head for asynchronous callbacks</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
        </seealso>
      </element>
      <element name="TAsyncCallQueue.Top">
        <short>The first queued method</short>
      </element>
      <element name="TAsyncCallQueue.Last">
        <short>The last queued method</short>
      </element>
      <!-- record type Visibility: default -->
      <element name="TAsyncCallQueues">
        <short>Management information for asynchronous callbacks</short>
        <descr>
          <p>Two queues are used:</p>
          <p>New calls are added to the Next queue.</p>
          <p> When the application starts processing the calls,
            the Next queue becomes the Cur queue, and a new Next queue is created.
            This simplifies thread-safe addition of further calls.</p>
        </descr>
        <seealso>
          <link id="TApplication.QueueAsyncCall"/>
        </seealso>
      </element>
      <element name="TAsyncCallQueues.CritSec">
        <short>The critical section for adding and removing queue elements</short>
        <descr>
        </descr>
      </element>
      <element name="TAsyncCallQueues.Cur">
        <short>The currently processed queue. Processed entries are removed</short>
        <descr>
        </descr>
      </element>
      <!-- variable Visibility: default -->
      <element name="TAsyncCallQueues.Next">
        <short>New calls are added to this queue</short>
        <descr>
        </descr>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationType">
        <short>
          Identifies the kind of device where the application currently runs
        </short>
        <descr>
          <p>
            <var>TApplicationType</var> identifies the kind of device where the application currently runs. Note that the same application can run on differing device types if it has a flexible user interface.
          </p>
        </descr>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationType.atDefault">
        <short/>
      </element>
      <element name="TApplicationType.atDesktop">
        <short/>
      </element>
      <element name="TApplicationType.atPDA">
        <short/>
      </element>
      <element name="TApplicationType.atKeyPadDevice">
        <short/>
      </element>
      <element name="TApplicationExceptionDlg">
        <short>Enumeration with dialog types for an application</short>
        <descr>
          <p>
            <var>TApplicationExceptionDlg</var> is an enumerated type with values that indicates the type of dialog displayed for an application exception. <var>TApplicationExceptionDlg</var> is the type used to implement the <var>ExceptionDialog</var> property in <var>TApplication</var> and <var>TApplicationProperties</var>.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.ExceptionDialog"/>
          <link id="TApplicationProperties.ExceptionDialog"/>
        </seealso>
      </element>
      <element name="TApplicationExceptionDlg.aedOkCancelDialog">
        <short>Exception handler window will be a dialog with Ok/Cancel buttons</short>
      </element>
      <element name="TApplicationExceptionDlg.aedOkMessageBox">
        <short>Exception handler window will be a simple message box</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TApplicationShowGlyphs">
        <short>Describes the policy for the application of how to show menu and button glyphs</short>
        <descr>
          <p>sbgAlways - show glyphs always (despite system preferences)</p>
          <p>sbgNever - show glyphs never (despite system preferences)</p>
          <p>sbgSystem - use system preferences for glyphs showing</p>
        </descr>
        <seealso>
          <link id="#LCL.Menus.TGlyphShowMode"/>
        </seealso>
        <notes><note>on Button or Tab controls, and menus?</note></notes>
      </element>
      <element name="TApplicationShowGlyphs.sbgAlways">
        <short>Show glyphs always</short>
      </element>
      <element name="TApplicationShowGlyphs.sbgNever">
        <short>Show glyphs never</short>
      </element>
      <element name="TApplicationShowGlyphs.sbgSystem">
        <short>Show glyphs according to the platform default</short>
      </element>
      <!-- enumeration type Visibility: default -->
      <element name="TTaskBarBehavior">
        <short>How forms are represented in the TaskBar</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TTaskBarBehavior.tbDefault">
        <short>Show TaskBar buttons according to the platform default</short>
      </element>
      <element name="TTaskBarBehavior.tbMultiButton">
        <short>Show buttons for Forms with ShowInTaskBar=stDefault</short>
      </element>
      <element name="TTaskBarBehavior.tbSingleButton">
        <short>Hide buttons for Forms with ShowInTaskBar=stDefault</short>
      </element>
      <element name="TApplicationDoubleBuffered">
        <short>
          Enumeration with values used in the DoubleBuffered property in TApplication
        </short>
        <descr></descr>
        <seealso></seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplicationDoubleBuffered.adbDefault">
        <short>
          Widget set dependent; for LCL/Win32 it is True,  unless in a remote desktop connection. For other widget sets it is False.
        </short>
      </element>
      <element name="TApplicationDoubleBuffered.adbFalse">
        <short></short>
      </element>
      <element name="TApplicationDoubleBuffered.adbTrue">
        <short></short>
      </element>
      <!-- object Visibility: default -->
      <element name="TApplication">
        <short>Application management and configuration for a GUI application.
        </short>
        <descr>
          <p>
            Provides a message loop, hooks for application event handlers, and more.
          </p>
          <p>
            Includes the useful function <var>MessageBox</var>, a simple dialog intended for displaying error messages, but also usable as an alternative to the various Message Dialogs.
          </p>
          <p>
            Other project types have a different Application class.
          </p>
        </descr>
        <seealso>
          <link id="TScreen"/>
        </seealso>
        <notes><note>or no?</note><note>?</note></notes>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplication.FApplicationHandlers">
        <short>Holds the registered notification handlers for the application</short>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplication.FApplicationType" link="TApplication.ApplicationType"/>
      <!-- variable Visibility: private -->
      <element name="TApplication.FCaptureExceptions" link="TApplication.CaptureExceptions"/>
      <!-- variable Visibility: private -->
      <element name="TApplication.FComponentsToRelease">
        <short>The list of components marked for release</short>
        <descr/>
        <seealso>
          <link id="TApplication.Release"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplication.FComponentsReleasing">
        <short>The list of components which currently are released (destroyed)</short>
        <descr></descr>
        <seealso>
          <link id="TApplication.Release"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplication.FCreatingForm"/>
      <element name="TApplication.FDoubleBuffered"/>
      <element name="TApplication.FExceptionDialog"/>
      <element name="TApplication.FExtendedKeysSupport"/>
      <element name="TApplication.FFindGlobalComponentEnabled" link="TApplication.FindGlobalComponentEnabled"/>
      <element name="TApplication.FFlags" link="TApplication.Flags"/>
      <element name="TApplication.FHint" link="TApplication.Hint"/>
      <element name="TApplication.FHintColor" link="TApplication.HintColor"/>
      <element name="TApplication.FHintControl" link="TApplication.HintControl"/>
      <element name="TApplication.FHintHidePause" link="TApplication.HintHidePause"/>
      <element name="TApplication.FHintHidePausePerChar" link="TApplication.HintHidePausePerChar"/>
      <element name="TApplication.FHintPause" link="TApplication.HintPause"/>
      <element name="TApplication.FHintRect">
        <short>The screen area of the current Hint window</short>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.FHintShortCuts" link="TApplication.HintShortCuts"/>
      <element name="TApplication.FHintShortPause" link="TApplication.HintShortPause"/>
      <element name="TApplication.FHintTimer">
        <short>The timer for showing and hiding Hints</short>
      </element>
      <element name="TApplication.FHintTimerType">
        <short>The Hint time mode</short>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.FHintWindow">
        <short>The current Hint window</short>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.FIcon" link="TApplication.Icon"/>
      <element name="TApplication.FBigIconHandle">
        <short>The Handle for the big application icon</short>
      </element>
      <element name="TApplication.FLayoutAdjustmentPolicy"/>
      <element name="TApplication.FMainFormOnTaskBar" link="TApplication.MainFormOnTaskBar"/>
      <element name="TApplication.FModalLevel" link="TApplication.ModalLevel"/>
      <element name="TApplication.FLayoutAdjustmentPolicy"/>
      <element name="TApplication.FMoveFormFocusToChildren"/>
      <element name="TApplication.FOnCircularException"/>
      <element name="TApplication.FOnGetMainFormHandle" link="TApplication.OnGetMainFormHandle"/>
      <element name="TApplication.FOnMessageDialogFinished"/>
      <element name="TApplication.FOnModalBegin" link="TApplication.OnModalBegin"/>
      <element name="TApplication.FOnModalEnd" link="TApplication.OnModalEnd"/>
      <element name="TApplication.FScaled"/>
      <element name="TApplication.FShowButtonGlyphs" link="TApplication.ShowButtonGlyphs"/>
      <element name="TApplication.FShowMenuGlyphs" link="TApplication.ShowMenuGlyphs"/>
      <element name="TApplication.FSmallIconHandle">
        <short>The Handle for the small application icon</short>
      </element>
      <element name="TApplication.FIdleLockCount">
        <short>Counter for nested Idle locks, preventing execution of OnIdle handlers</short>
      </element>
      <element name="TApplication.FLastKeyDownSender">
        <short>Cached key event parameter</short>
      </element>
      <element name="TApplication.FLastKeyDownKeys">
        <short>List of key values for the last KeyDown sender</short>
      </element>
      <element name="TApplication.FLastKeyDownShift">
        <short>Cached key event parameter</short>
      </element>
      <element name="TApplication.FMainForm" link="TApplication.MainForm"/>
      <element name="TApplication.FMouseControl" link="TApplication.MouseControl"/>
      <element name="TApplication.FNavigation" link="TApplication.Navigation"/>
      <element name="TApplication.FOldExceptProc">
        <short>The previously installed exception handler</short>
      </element>
      <element name="TApplication.FOldExitProc">
        <short>The previously installed Exit procedure</short>
      </element>
      <element name="TApplication.FOnActionExecute" link="TApplication.OnActionExecute"/>
      <element name="TApplication.FOnActionUpdate" link="TApplication.OnActionUpdate"/>
      <element name="TApplication.FOnActivate" link="TApplication.OnActivate"/>
      <element name="TApplication.FOnDeactivate" link="TApplication.OnDeactivate"/>
      <element name="TApplication.FOnDestroy" link="TApplication.OnDestroy"/>
      <element name="TApplication.FOnDropFiles" link="TApplication.OnDropFiles"/>
      <element name="TApplication.FOnHelp" link="TApplication.OnHelp"/>
      <element name="TApplication.FOnHint" link="TApplication.OnHint"/>
      <element name="TApplication.FOnIdle" link="TApplication.OnIdle"/>
      <element name="TApplication.FOnIdleEnd" link="TApplication.OnIdleEnd"/>
      <element name="TApplication.FOnEndSession" link="TApplication.OnEndSession"/>
      <element name="TApplication.FOnQueryEndSession" link="TApplication.OnQueryEndSession"/>
      <element name="TApplication.FOnMinimize" link="TApplication.OnMinimize"/>
      <element name="TApplication.FOnRestore" link="TApplication.OnRestore"/>
      <element name="TApplication.FOnShortcut" link="TApplication.OnShortcut"/>
      <element name="TApplication.FOnShowHint" link="TApplication.OnShowHint"/>
      <element name="TApplication.FOnUserInput" link="TApplication.OnUserInput"/>
      <element name="TApplication.FAsyncCall" link="TApplication.QueueAsyncCall">
        <short>Queues for asynchronous calls</short>
      </element>
      <element name="TApplication.FShowHint" link="TApplication.ShowHint"/>
      <element name="TApplication.FShowMainForm" link="TApplication.ShowMainForm"/>
      <element name="TApplication.FLastMousePos">
        <short>Cached mouse event parameter</short>
      </element>
      <element name="TApplication.FLastMouseControl">
        <short>Cached mouse event parameter</short>
      </element>
      <element name="TApplication.FLastMouseControlValid">
        <short>Cached mouse event parameter</short>
      </element>
      <element name="TApplication.FBidiMode" link="TApplication.BiDiMode"/>
      <element name="TApplication.FRestoreStayOnTop">
        <short>The list of all forms that should be restored to StayOnTop</short>
        <descr>The list is created in RemoveStayOnTop, processed in RestoreStayOnTop.</descr>
      </element>
      <element name="TApplication.FTaskBarBehavior" link="TApplication.TaskBarBehavior"/>
      <element name="TApplication.FUpdateFormatSettings"/>
      <element name="TApplication.FRemoveStayOnTopCounter"/>
      <element name="TApplication.FExceptionCounter"/>
      <element name="TApplication.DoOnIdleEnd">
        <short>Notifies the OnIdleEnd handlers; called when the application exits Idle state</short>
      </element>
      <element name="TApplication.GetActive" link="TApplication.Active"/>
      <element name="TApplication.GetActive.Result">
        <short/>
      </element>
      <element name="TApplication.GetCurrentHelpFile">
        <short>Gets the HelpFile name for the active form, or the Application</short>
        <descr>
          <p>
            <var>GetCurrentHelpFile</var> is a <var>String</var> function used to get the help file name for the active form or application.
          </p>
          <p>
            <var>GetCurrentHelpFile</var> checks for an active form in the <var>Screen</var>  singleton. If a form is active, the file name in its <var>HelpFile</var> property is used as the return value. If a form is not active, the <var>HelpFile</var> in the <var>Application</var> instance is used.
          </p>
        </descr>
        <seealso>
          <link id="TScreen.ActiveCustomForm"/>
          <link id="TCustomForm.HelpFile"/>
          <link id="TApplication.HelpFile"/>
        </seealso>
      </element>
      <element name="TApplication.GetCurrentHelpFile.Result">
        <short>Help file name located in the method</short>
      </element>
      <element name="TApplication.GetExename">
        <short>Gets the name of the executable for the application</short>
        <descr>
          <p>
            <var>GetExename</var> is a <var>String</var> function used to get the name of the executable file which started the application. The return value contains the first commandline parameter (ordinal position 0) returned from the <var>ParamStrUTF8</var> routine in <file>LazUtils</file>.
          </p>
        </descr>
        <seealso>
          <link id="LazUtils.LazUTF8.ParamStrUTF8"/>
        </seealso>
      </element>
      <element name="TApplication.GetExename.Result">
        <short>Name of the executable file used to start the application</short>
      </element>
      <element name="TApplication.GetHandle">
        <short>Gets the value for the Handle property</short>
        <descr>
          Returns the AppHandle property from the WidgetSet singleton.
        </descr>
        <seealso>
          <link id="TApplication.Handle"/>
        </seealso>
      </element>
      <element name="TApplication.GetHandle.Result">
        <short>The Handle for the application</short>
      </element>
      <element name="TApplication.GetMainFormHandle">
        <short>Determines the main form handle, using all available handlers</short>
        <seealso>
          <link id="TApplication.OnGetMainFormHandle"/>
          <link id="TApplicationHandlerType.ahtOnGetMainFormHandle"/>
        </seealso>
      </element>
      <element name="TApplication.GetMainFormHandle.Result">
        <short/>
      </element>
      <element name="TApplication.GetTitle">
        <short>
          When no Title was stored, extracts the program name from the commandline arguments
        </short>
        <descr/>
      </element>
      <element name="TApplication.GetTitle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.FreeIconHandles">
        <short>Destroys the application icons</short>
        <descr>
          <p>
            <var>FreeIconHandles</var> is a procedure used to free icon handles used in the application. FreeIconHandles ensures that the internal members for the small and large icon handles are destroyed (when assigned). The <var>DestroyIcon</var> routine is called to destroy each of the icon handles using the correct routine for the widget set implementation.
          </p>
          <p>
            FreeIconHandles is called from the destructor for the class instance, and when an icon for the application has been changed.
          </p>
        </descr>
        <errors>
        </errors>
        <seealso>
          <link id="TApplication.Destroy"/>
          <link id="TApplication.IconChanged"/>
          <link id="TApplication.SmallIconHandle"/>
          <link id="TApplication.BigIconHandle"/>
        </seealso>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.IconChanged">
        <short>Loads the new application icons, notifies the widget set and all forms</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IconChanged.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetBidiMode" link="TApplication.BiDiMode"/>
      <element name="TApplication.SetBidiMode.AValue">
      <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetFlags" link="TApplication.Flags"/>
      <element name="TApplication.SetFlags.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetMainFormOnTaskBar" link="TApplication.MainFormOnTaskBar"/>
      <element name="TApplication.SetMainFormOnTaskBar.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetNavigation" link="TApplication.Navigation"/>
      <element name="TApplication.SetNavigation.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetShowButtonGlyphs" link="TApplication.ShowButtonGlyphs"/>
      <element name="TApplication.SetShowButtonGlyphs.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetShowMenuGlyphs" link="TApplication.ShowMenuGlyphs"/>
      <element name="TApplication.SetShowMenuGlyphs.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetTaskBarBehavior" link="TApplication.TaskBarBehavior"/>
      <element name="TApplication.SetTaskBarBehavior.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.UpdateMouseControl">
        <short>Handles mouse moving onto a new control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.UpdateMouseControl.NewMouseControl">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.UpdateMouseHint">
        <short>Sets Hint to the (new) hint that applies to CurrentControl</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.UpdateMouseHint.CurrentControl">
        <short>The control under the mouse</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetCaptureExceptions" link="TApplication.CaptureExceptions"/>
      <element name="TApplication.SetCaptureExceptions.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetHint" link="TApplication.Hint"/>
      <element name="TApplication.SetHint.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetHintColor" link="TApplication.HintControl"/>
      <element name="TApplication.SetHintColor.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetIcon" link="TApplication.Icon"/>
      <element name="TApplication.SetIcon.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.SetShowHint" link="TApplication.ShowHint"/>
      <element name="TApplication.SetShowHint.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.StopHintTimer">
        <short>Disables the Hint timer</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: private -->
      <element name="TApplication.ValidateHelpSystem">
        <short>
          Checks for an installed <link id="#lcl.HelpIntfs.HelpManager">HelpManager</link>
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ValidateHelpSystem.Result">
        <short>True when HelpManager is not Nil</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.WndProc" link="#LCL.Controls.TControl.WndProc"/>
      <element name="TApplication.WndProc.AMessage">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TApplication.DispatchAction">
        <short>Asks the active form and MainForm to handle the action</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TApplication.DispatchAction.Result">
        <short>True when the action was handled</short>
      </element>
      <element name="TApplication.DispatchAction.Msg">
        <short/>
      </element>
      <element name="TApplication.DispatchAction.Action">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.AddHandler">
        <short>Adds an application notification handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.AddHandler.HandlerType">
        <short/>
      </element>
      <element name="TApplication.AddHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.RemoveHandler">
        <short>Removes an application notification handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveHandler.HandlerType">
        <short/>
      </element>
      <element name="TApplication.RemoveHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.RunLoop">
        <short>Encapsulates the application message loop (HandleMessage)</short>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.Activate">
        <short>Handler for application activation, notifies all activation handlers</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TApplication.Deactivate">
        <short>Handler for application deactivation, notifies all deactivation handlers</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.Deactivate.Force">
        <short>True when called from the widget set</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TApplication.GetConsoleApplication">
        <short>Here: returns False, because this is a GUI application.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.GetConsoleApplication.Result">
        <short>False for a GUI application</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyIdleHandler">
        <short>Notifies all Idle handlers</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnIdle"/>
          <link id="TApplicationHandlerType.ahtIdle"/>
        </seealso>
      </element>
      <element name="TApplication.NotifyIdleHandler.Done">
        <short>True when all handlers are done, meaning: wait for next message</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyIdleEndHandler">
        <short>Notifies all Idle End handlers, when a new message arrived</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnIdleEnd"/>
          <link id="TApplicationHandlerType.ahtIdleEnd"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyActivateHandler">
        <short>Notifies all Activation handlers</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnActivate"/>
          <link id="TApplicationHandlerType.ahtActivate"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyDeactivateHandler">
        <short>Notifies all Deactivation handlers</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnDeactivate"/>
          <link id="TApplicationHandlerType.ahtDeactivate"/>
        </seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.NotifyCustomForms">
        <short>Notifies all CustomForms of Msg arrived</short>
        <descr>
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TApplication.NotifyCustomForms.Msg">
        <short>The message to process</short>
      </element>
      <!-- function Visibility: protected -->
      <element name="TApplication.IsHintMsg">
        <short>NOP, exists for Delphi compatibility only</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IsHintMsg.Result">
        <short>Always False</short>
      </element>
      <element name="TApplication.IsHintMsg.Msg">
        <short/>
      </element>
      <!-- function Visibility: protected -->
      <element name="TApplication.DoOnHelp">
        <short>
          OnHelp message handler. Tries the OnHelp handlers for the active form, and the Application,  as well as application Help handlers.
        </short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.OnHelp"/>
          <link id="TApplicationHandlerType.ahtHelp"/>
        </seealso>
      </element>
      <element name="TApplication.DoOnHelp.Result">
        <short>True when the message was handled</short>
      </element>
      <element name="TApplication.DoOnHelp.Command">
        <short/>
      </element>
      <element name="TApplication.DoOnHelp.Data">
        <short/>
      </element>
      <element name="TApplication.DoOnHelp.CallHelp">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.DoOnMouseMove">
        <short>OnMouseMove message handler, updates the Hint</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.ShowHintWindow">
        <short>Shows or hides the Hint window</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ShowHintWindow.Info">
        <short>Is updated with the Hint related information</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.OnHintTimer">
        <short>Event handler for timing the duration of hints</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.OnHintTimer.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.SetTitle" link="TApplication.Title"/>
      <element name="TApplication.SetTitle.AValue">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.StartHintTimer">
        <short>Starts the timer for display of a hint message</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <element name="TApplication.StartHintTimer.Interval">
        <short/>
      </element>
      <element name="TApplication.StartHintTimer.TimerType">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.UpdateVisible">
        <short>Asks the widget set to update the TaskBar entries</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.DoIdleActions">
        <short>Updates all Actions, hides splash screens</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.MenuPopupHandler">
        <short>Hides the Hint window</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.MenuPopupHandler.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.ProcessAsyncCallQueue">
        <short>Calls all methods queued by QueueAsyncCall</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.FreeComponent" link="TApplication.ReleaseComponents"/>
      <element name="TApplication.FreeComponent.Data">
        <short>Ignored, should be zero</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.ReleaseComponents">
        <short>Destroys all components marked for release</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.DoBeforeFinalization">
        <short>Destroys all components</short>
        <descr>
          <p>
            Called from the <var>BeforeFinalization</var> routine which is used as the <var>ExitProc</var> handler in the application instance.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplication.GetParams">
        <short>Returns the commandline argument at the specified position</short>
      </element>
      <element name="TApplication.GetParams.Result">
        <short/>
      </element>
      <element name="TApplication.GetParams.Index">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TApplication.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TApplication.Create.AOwner">
        <short>The Owner object that invoked this instance of TApplication</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TApplication.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            Destroy is the overridden destructor for the class instance.
          </p>
          <p>
            <var>Destroy</var> ensures that the value <var>AppDestroying</var> is included in the <var>Flags</var> for the application, and signals the <var>OnDestroy</var> event handler (when assigned). Destroy calls the <var>ProcessAsyncCallQueue</var> method to process / handle queued asynchronous method calls pending for the application instance.
          </p>
          <p>
            Hint display is cancelled and suppressed while the application is shutting down. The action component for the application is set to <b>Nil</b> to prevent execution of associated actions during shutdown.
          </p>
          <p>
            Destroy frees resources allocated in the application instance, including the Icon and any Icon handles currently in use.  Handlers added to application instance are also freed.
          </p>
          <p>
            Destroy calls the inherited destructor, and discards any pending asynchronous calls not previously handled for the application instance. Exception handling is restored to the state on entry to the Create constructor. Finally, the Application class instance is set to <b>Nil</b>.
          </p>
        </descr>
        <errors>
          Destroy calls <var>RaiseGDBException</var> to raise an exception if the current class instance is unassigned (contains <b>Nil</b>). Uses the exception message 'TApplication.Destroy Self=nil'.
        </errors>
        <seealso></seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ActivateHint">
        <short/>
        <descr>
        </descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.ActivateHint.CursorPos">
        <short/>
      </element>
      <element name="TApplication.ActivateHint.CheckHintControlChange">
        <short/>
      </element>
      <!-- function Visibility: private -->
      <element name="TApplication.GetControlAtMouse">
        <short>Finds the control under the mouse</short>
        <descr>Updates the LastMouse... info.</descr>
        <seealso/>
      </element>
      <element name="TApplication.GetControlAtMouse.Result">
        <short>The control, or Nil if no control is found</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ControlDestroyed">
        <short>Clears all references to the destroyed control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ControlDestroyed.AControl">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.BigIconHandle">
        <short>The Handle of the large application Icon</short>
        <seealso>
          <link id="TApplication.Icon"/>
        </seealso>
      </element>
      <element name="TApplication.BigIconHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.SmallIconHandle">
        <short>The Handle of the small application Icon</short>
        <seealso>
          <link id="TApplication.Icon"/>
        </seealso>
      </element>
      <element name="TApplication.SmallIconHandle.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.BringToFront">
        <short>Asks the widget set to bring the application's form(s) to the front
        </short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.CreateForm">
        <short>Creates a Form or component, owned by Application</short>
        <descr>
          <remark>
            Please note: The method name is confusing and kept only for Delphi compatibility. The method can actually create any kind of component.
          </remark>
          <p>
            CreateForm creates a Component instance of the given class, and sets the pointer to the component variable. If it is a form, it will be added to the form list in the application.
          </p>
          <p>
            A splash form is shown immediately.
          </p>
        </descr>
        <seealso/>
        <notes>
          <note>and loads the component?</note>
        </notes>
      </element>
      <element name="TApplication.CreateForm.InstanceClass">
        <short>The component class</short>
      </element>
      <element name="TApplication.CreateForm.Reference">
        <short>The variable receiving the new component reference</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.UpdateMainForm">
        <short>
          When MainForm is Nil, this form becomes the application MainForm
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.UpdateMainForm.AForm">
        <short>The form that may become the MainForm</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.QueueAsyncCall">
        <short>Inserts an asynchronous call into the queue</short>
        <descr>This is thread safe.</descr>
        <errors>Exceptions on various inconsistencies of the queue.
        </errors>
        <seealso/>
        <example file="forms/tapplication_queueasynccall.pas"/>
      </element>
      <element name="TApplication.QueueAsyncCall.AMethod">
        <short>The method to call asynchronously</short>
      </element>
      <element name="TApplication.QueueAsyncCall.Data">
        <short>The argument passed to the method</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveAsyncCalls">
        <short>Removes all calls added via QueueAsyncCall</short>
        <descr>This is thread safe.</descr>
        <errors>Exceptions on various inconsistencies of the queue.</errors>
      </element>
      <element name="TApplication.RemoveAsyncCalls.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ReleaseComponent">
        <short>Safe destruction of a component, can be requested
          by the component itself</short>
        <descr>
          <p>
            Unless the application is shutting down, all requests are queued. Queued requests are processed when the application is not currently processing a message.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="TApplication.ReleaseComponent.AComponent">
        <short>The component to destroy</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.ExecuteAction">
        <short>Invokes the <var>OnActionExecute</var> handler</short>
        <seealso>
          <link id="#rtl.Classes.TComponent.ExecuteAction"/>
        </seealso>
      </element>
      <element name="TApplication.ExecuteAction.Result">
        <short>True when the Action was handled</short>
      </element>
      <element name="TApplication.ExecuteAction.ExeAction">
        <short>The Action to execute</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.UpdateAction">
        <short>Invokes the <var>OnActionUpdate</var> handler</short>
        <descr/>
        <seealso>
          <link id="#rtl.Classes.TComponent.UpdateAction">TComponent.UpdateAction</link>
        </seealso>
      </element>
      <element name="TApplication.UpdateAction.Result">
        <short/>
      </element>
      <element name="TApplication.UpdateAction.TheAction">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.HandleException">
        <short>
          <var>HandleException</var> method for handling an exception;
          attempts to maintain program execution if possible, otherwise exits gracefully
        </short>
        <descr>
          <p>
            Individual exception handler methods should be supplied by the application programmer, to override place-holder entries declared in ancestor classes. This method checks whether the application is halted when an exception occurs, or invokes the appropriate handler. It also writes details about the exception to the appropriate place for debugging.
          </p>
        </descr>
        <seealso>
          <link id="#fcl.CustApp.TCustomApplication.HandleException"/>
        </seealso>
      </element>
      <element name="TApplication.HandleException.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.HandleMessage">
        <short>Handles all messages, and enters the Idle state</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.HelpCommand">
        <short>Show help</short>
        <descr>Currently relies on OnHelp handlers. CallHelp is not implemented.</descr>
        <errors>
        </errors>
        <seealso>
        </seealso>
        <notes><note>what?</note></notes>
      </element>
      <element name="TApplication.HelpCommand.Result">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.HelpCommand.Command">
        <short/>
      </element>
      <element name="TApplication.HelpCommand.Data">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.HelpContext">
        <short>Show context sensitive help</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.HelpContext.Result">
        <short>Request handled</short>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.HelpContext.Context">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.HelpKeyword">
        <short>Show help for a keyword</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.HelpKeyword.Result">
        <short/>
      </element>
      <element name="TApplication.HelpKeyword.Keyword">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ShowHelpForObject">
        <short>When Sender is a TControl, invoke its ShowHelp method</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ShowHelpForObject.Sender">
        <short>Should be a TControl, else nothing will happen</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveStayOnTop">
        <short>
          Remove StayOnTop from all forms. Builds a form list for use in RestoreStayOnTop.
        </short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.RestoreStayOnTop"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveStayOnTop.ASystemTopAlso">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RestoreStayOnTop">
        <short>Restores StayOnTop for all forms changed by RemoveStayOnTop</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.RemoveStayOnTop"/>
        </seealso>
      </element>
      <element name="TApplication.RestoreStayOnTop.ASystemTopAlso">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.IsWaiting">
        <short>True if the application is awaiting an event</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.IsWaiting.Result">
        <short>True if the application is in AppWaiting state</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.CancelHint">
        <short>Called when the Hint time has expired, to stop showing the Hint.</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.HideHint">
        <short>Hides the Hint window</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.HintMouseMessage">
        <short>Called when the the mouse is over a control with a Hint</short>
        <descr>Does nothing</descr>
        <seealso/>
        <notes>
          <note>?</note><note>exists for Delphi compatibility only?</note>
        </notes>
      </element>
      <element name="TApplication.HintMouseMessage.Control">
        <short/>
      </element>
      <element name="TApplication.HintMouseMessage.AMessage">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Initialize">
        <short>Initializes the widget set (and more)</short>
        <descr>
        </descr>
        <seealso>
          <link id="#fcl.CustApp.TCustomApplication.Initialize"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.MessageBox">
        <short>Display an message dialog with several response buttons</short>
        <descr>
          <p>
            The function is used internally to display messages during the handling of <var>Exceptions</var>, but is also available to application programmers as an alternative to some of the message dialogs found in the <file>Dialogs</file> unit.
          </p>
          <p>
            The function returns an integer value corresponding to the button that was pressed; its value can be determined by reference to the constants [IDOK..IDHELP].
          </p>
        </descr>
        <seealso>
          <link id="#lcl.Dialogs.MessageDlg">MessageDlg</link>
        </seealso>
        <example file="dialogs/displaymessagebox.pas"/>
      </element>
      <element name="TApplication.MessageBox.Result">
        <short>Indicates the pressed button</short>
        <descr>
          <p>Can be one of the following values:</p>
          <ul>
            <li>IDOK</li>
            <li>IDCANCEL</li>
            <li>IDABORT</li>
            <li>IDRETRY</li>
            <li>IDIGNORE</li>
            <li>IDYES</li>
            <li>IDNO</li>
            <li>IDCLOSE</li>
            <li>IDHELP</li>
          </ul>
        </descr>
      </element>
      <element name="TApplication.MessageBox.Text">
        <short>The text in the MessageBox</short>
        <descr/>
      </element>
      <element name="TApplication.MessageBox.Caption">
        <short>The Caption of the MessageBox</short>
        <descr/>
      </element>
      <element name="TApplication.MessageBox.Flags">
        <short>The icon and buttons appearing in the box.
        </short>
        <descr>
          <p>
            Several constants are declared in the LCLType unit.
          </p>
          <p>Add (better: OR) an icon constant and a buttons constant. For example:</p>
          <code>MB_ABORTRETRYIGNORE + MB_ICONQUESTION</code>
          <p>Causes the application to display a query (?) icon in a box with three buttons: ABORT RETRY IGNORE.</p>
          <p>Buttons can be one of:</p>
          <ul>
            <li>MB_OK</li>
            <li>MB_OKCANCEL</li>
            <li>MB_ABORTRETRYIGNORE</li>
            <li>MB_YESNOCANCEL</li>
            <li>MB_YESNO</li>
            <li>MB_RETRYCANCEL</li>
          </ul>
          <p>The icon can be one of:</p>
          <ul>
            <li>MB_ICONHAND</li>
            <li>MB_ICONQUESTION</li>
            <li>MB_ICONEXCLAMATION</li>
            <li>MB_ICONASTERISK</li>
            <li>MB_ICONWARNING = MB_ICONEXCLAMATION</li>
            <li>MB_ICONERROR = MB_ICONHAND</li>
            <li>MB_ICONSTOP = MB_ICONHAND</li>
            <li>MB_ICONINFORMATION = MB_ICONASTERISK</li>
          </ul>
        </descr>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Minimize">
        <short>Asks the widget set to minimize the application.
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ModalStarted">
        <short>Called when a form is shown modally</short>
        <descr>Invokes all OnModalBegin handlers when entering Modal state.
        </descr>
        <seealso>
          <link id="TApplication.ModalFinished"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ModalFinished">
        <short>Called when a modal form is closed</short>
        <descr>Invokes all OnModalEnd handlers when exiting Modal state.
        </descr>
        <seealso>
          <link id="TApplication.ModalStarted"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Restore">
        <short>Restores the previously minimized application.
        </short>
        <descr/>
        <seealso>
          <link id="TApplication.Minimize"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Notification">
        <short>Invokes the notification handlers.
        </short>
        <descr>
          <p>
            Special handling, here: Clears the reference to a removed component, terminates the application when the MainForm is removed.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Notification">TComponent.Notification</link>
        </seealso>
      </element>
      <element name="TApplication.Notification.AComponent">
        <short/>
      </element>
      <element name="TApplication.Notification.Operation">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ProcessMessages">
        <short>
          Call this method during lengthy operations, to keep the GUI responsive
        </short>
        <descr>
          Processes all waiting messages, then the queued asynchronous callbacks.
        </descr>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Idle">
        <short>Invoked when the application enters the idle state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.Idle.Wait">
        <short>Wait for next message?</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Run" link="#fcl.CustApp.TCustomApplication.Run">
        <short>MainForm is loaded and control is passed to the event loop</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.RunLoop"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ShowException" link="#fcl.CustApp.TCustomApplication.ShowException">
        <short>Shows the exception message and asks the user to abort or continue</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ShowException.E">
        <short>The exception to show</short>
        <seealso>
          <link id="#rtl.sysutils.exception"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.Terminate" link="#fcl.CustApp.TCustomApplication.Terminate">
        <short>The application is terminated and the component engine is shutdown</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DisableIdleHandler">
        <short>
          Blocks Idle handling. Can be called more often, every call must be followed by EnableIdleHandler.
        </short>
        <descr/>
        <seealso>
          <link id="TApplication.EnableIdleHandler"/>
        </seealso>
        <notes><note>what does this mean to application behavior?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.EnableIdleHandler">
        <short>Resume Idle handling</short>
        <descr/>
        <errors>GDB exception when not previously disabled.</errors>
        <seealso>
          <link id="TApplication.DisableIdleHandler"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.NotifyUserInputHandler">
        <short>Notifies all user input handlers</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtUserInput"/>
        </seealso>
        <notes><note>of what?</note></notes>
      </element>
      <element name="TApplication.NotifyUserInputHandler.Msg">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.NotifyKeyDownBeforeHandler">
        <short>Notifies all ahtKeyDownBefore handlers</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtKeyDownBefore"/>
        </seealso>
      </element>
      <element name="TApplication.NotifyKeyDownBeforeHandler.Sender">
        <short/>
      </element>
      <element name="TApplication.NotifyKeyDownBeforeHandler.Key">
        <short/>
      </element>
      <element name="TApplication.NotifyKeyDownBeforeHandler.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.NotifyKeyDownHandler">
        <short>Notifies all ahtKeyDownAfter handlers, eventually reacts on F1 (Help)</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtKeyDownAfter"/>
        </seealso>
      </element>
      <element name="TApplication.NotifyKeyDownHandler.Sender">
        <short/>
      </element>
      <element name="TApplication.NotifyKeyDownHandler.Key">
        <short/>
      </element>
      <element name="TApplication.NotifyKeyDownHandler.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ControlKeyDown">
        <short>Handles KeyDown events in a Control, e.g. handles navigation keys</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ControlKeyDown.Sender">
        <short/>
      </element>
      <element name="TApplication.ControlKeyDown.Key">
        <short/>
      </element>
      <element name="TApplication.ControlKeyDown.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.ControlKeyUp">
        <short>Handles KeyUp events in a Control, e.g. handles Enter and Esc keys</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.ControlKeyUp.Sender">
        <short/>
      </element>
      <element name="TApplication.ControlKeyUp.Key">
        <short/>
      </element>
      <element name="TApplication.ControlKeyUp.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnIdleHandler">
        <short>Adds an application Idle handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtIdle"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnIdleHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnIdleHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnIdleHandler">
        <short>Removes an application Idle handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtIdle"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnIdleHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnIdleEndHandler">
        <short>Adds an application IdleEnd handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtIdleEnd"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnIdleEndHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnIdleEndHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnIdleEndHandler">
        <short>Removes an application IdleEnd handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtIdleEnd"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnIdleEndHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnUserInputHandler">
        <short>Adds an application user input handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtUserInput"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnUserInputHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnUserInputHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnUserInputHandler">
        <short>Removes an application user input handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtUserInput"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnUserInputHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnKeyDownBeforeHandler">
        <short>Adds an application key down before interface handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtKeyDownBefore"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnKeyDownBeforeHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnKeyDownBeforeHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnKeyDownBeforeHandler">
        <short>Removes an application key down before interface handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtKeyDownBefore"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnKeyDownBeforeHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnKeyDownHandler">
        <short>Adds an application key down after interface handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtKeyDownAfter"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnKeyDownHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnKeyDownHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnKeyDownHandler">
        <short>Removes an application key down after interface handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtKeyDownAfter"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnKeyDownHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnActivateHandler">
        <short>Adds an application activation handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtActivate"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnActivateHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnActivateHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnActivateHandler">
        <short>Removes an application activation handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtActivate"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnActivateHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnDeactivateHandler">
        <short>Adds an application deactivation handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtDeactivate"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnDeactivateHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnDeactivateHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnDeactivateHandler">
        <short>Removes an application deactivation handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtDeactivate"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnDeactivateHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnExceptionHandler">
        <short>Adds an application exception handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtException"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnExceptionHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnExceptionHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnExceptionHandler">
        <short>Removes an application exception handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtException"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnExceptionHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnEndSessionHandler">
        <short>Adds an application logoff handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtEndSession"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.AddOnEndSessionHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnEndSessionHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnEndSessionHandler">
        <short>Removes an application logoff handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtEndSession"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="TApplication.RemoveOnEndSessionHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnQueryEndSessionHandler">
        <short>Adds an application logoff query handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtQueryEndSession"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnQueryEndSessionHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnQueryEndSessionHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnQueryEndSessionHandler">
        <short>Removes an application logoff query handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtQueryEndSession"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnQueryEndSessionHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnMinimizeHandler">
        <short>Adds an application minimizing handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtMinimize"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnMinimizeHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnMinimizeHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnMinimizeHandler">
        <short>Removes an application minimizing handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtMinimize"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnMinimizeHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnModalBeginHandler">
        <short>Adds an application becoming modal handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtModalBegin"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnModalBeginHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnModalBeginHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnModalBeginHandler">
        <short>Removes an application becoming modal handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtModalBegin"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnModalBeginHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnModalEndHandler">
        <short>Adds an application exiting modal state handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtModalEnd"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnModalEndHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnModalEndHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnModalEndHandler">
        <short>Removes an application exiting modal state handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtModalEnd"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnModalEndHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnRestoreHandler">
        <short>Adds an application exiting minimized state handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtRestore"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnRestoreHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnRestoreHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnRestoreHandler">
        <short>Removes an application exiting minimized state handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtRestore"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnRestoreHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnDropFilesHandler">
        <short>Adds an application dropped files handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtDropFiles"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnDropFilesHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnDropFilesHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnDropFilesHandler">
        <short>Removes an application dropped files handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtDropFiles"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnDropFilesHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnHelpHandler">
        <short>Adds an application Help handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtHelp"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnHelpHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnHelpHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnHelpHandler">
        <short>Removes an application Help handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtHelp"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnHelpHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnHintHandler">
        <short>Adds an application Hint handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtHint"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnHintHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnHintHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnHintHandler">
        <short>Removes an application Hint handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtHint"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnHintHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnShowHintHandler">
        <short>Adds an application Hint show handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtShowHint"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnShowHintHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnShowHintHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnShowHintHandler">
        <short>Removes an application Hint show handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtShowHint"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnShowHintHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.AddOnGetMainFormHandleHandler">
        <short>Adds an application MainForm Handle handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtGetMainFormHandle"/>
        </seealso>
      </element>
      <element name="TApplication.AddOnGetMainFormHandleHandler.Handler">
        <short/>
      </element>
      <element name="TApplication.AddOnGetMainFormHandleHandler.AsFirst">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveOnGetMainFormHandleHandler">
        <short>Removes an application MainForm Handle handler</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtGetMainFormHandle"/>
        </seealso>
      </element>
      <element name="TApplication.RemoveOnGetMainFormHandleHandler.Handler">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.RemoveAllHandlersOfObject">
        <short>Removes all handlers implemented in the given object</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.RemoveAllHandlersOfObject.AnObject">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DoBeforeMouseMessage">
        <short>Things to be done before a mouse message is processed</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoBeforeMouseMessage.CurMouseControl">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.IsShortcut">
        <short>Asks all shortcut handlers to handle the key</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.IsShortcut.Result">
        <short>True when the shortcut was handled</short>
      </element>
      <element name="TApplication.IsShortcut.Message">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfQueryEndSession">
        <short>Called by the interface to confirm the end of a session</short>
        <descr>Asks all QueryEndSession handlers to confirm termination of the application.
        </descr>
        <seealso>
          <link id="TApplication.OnQueryEndSession"/>
          <link id="TApplicationHandlerType.ahtQueryEndSession"/>
        </seealso>
      </element>
      <element name="TApplication.IntfQueryEndSession.Cancel">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfEndSession">
        <short>Called by the interface when the session ends</short>
        <descr>Notifies all OnEndSession handlers.</descr>
        <seealso>
          <link id="TApplication.OnEndSession"/>
          <link id="TApplicationHandlerType.ahtEndSession"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfAppActivate">
        <short>Called by the interface on application activation</short>
        <descr>Notifies all activation handlers.</descr>
        <seealso>
          <link id="TApplication.OnActivate"/>
          <link id="TApplicationHandlerType.ahtActivate"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfAppDeactivate">
        <short>Called by the interface on application deactivation</short>
        <descr></descr>
        <seealso>
          <link id="TApplication.OnDeactivate"/>
          <link id="TApplicationHandlerType.ahtDeactivate"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfAppMinimize">
        <short>Called by the interface when the application is minimized</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnMinimize"/>
          <link id="TApplicationHandlerType.ahtMinimize"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfAppRestore">
        <short>Called by the interface when the application is restored</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnRestore"/>
          <link id="TApplicationHandlerType.ahtRestore"/>
        </seealso>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfDropFiles">
        <short>Called by the interface when files have been dropped</short>
        <descr/>
        <seealso>
          <link id="TApplication.OnDropFiles"/>
          <link id="TApplicationHandlerType.ahtDropFiles"/>
        </seealso>
      </element>
      <element name="TApplication.IntfDropFiles.FileNames">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.IntfThemeOptionChange">
        <short>Called by the interface when a theme option has changed</short>
        <descr/>
        <seealso></seealso>
      </element>
      <element name="TApplication.IntfThemeOptionChange.AThemeServices">
        <short/>
      </element>
      <element name="TApplication.IntfThemeOptionChange.AOption">
        <short/>
      </element>
      <element name="TApplication.IsRightToLeft">
        <short>Indicates if BiDiMode contains a value other than bdLeftToRight</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TApplication.IsRightToLeft.Result">
        <short></short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.IsRTLLang">
        <short>Checks the given language name for use of right-to-left reading</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TApplication.IsRTLLang.Result">
        <short>True when the language code uses right-to-left reading</short>
      </element>
      <element name="TApplication.IsRTLLang.ALang">
        <short>ISO language code examined in the method</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.Direction">
        <short>Gets the BidiMode value for the specified language name</short>
        <descr></descr>
        <errors></errors>
        <seealso></seealso>
      </element>
      <element name="TApplication.Direction.Result">
        <short>TBiDiMode value for the specified language</short>
      </element>
      <element name="TApplication.Direction.ALang">
        <short>ISO language name examined in the method</short>
      </element>
      <!-- function Visibility: public -->
      <element name="TApplication.DoArrowKey">
        <short>Uses arrow keys for navigation, if enabled</short>
      </element>
      <element name="TApplication.DoArrowKey.AControl">
        <short>The control receiving the key</short>
      </element>
      <element name="TApplication.DoArrowKey.Key">
        <short>The virtual key; becomes VK_UNKNOWN when handled</short>
      </element>
      <element name="TApplication.DoArrowKey.Shift">
        <short>The active modifier keys</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DoTabKey">
        <short>Uses the Tab key for navigation, if enabled</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoTabKey.AControl">
        <short>The control receiving the key</short>
      </element>
      <element name="TApplication.DoTabKey.Key">
        <short>The virtual key; becomes VK_UNKNOWN when handled</short>
      </element>
      <element name="TApplication.DoTabKey.Shift">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DoEscapeKey">
        <short>Interprets Esc as Cancel action, if applicable</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoEscapeKey.AControl">
        <short>The control receiving the key</short>
      </element>
      <element name="TApplication.DoEscapeKey.Key">
        <short>The virtual key; becomes VK_UNKNOWN when handled</short>
      </element>
      <element name="TApplication.DoEscapeKey.Shift">
        <short>The active modifier keys</short>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TApplication.DoReturnKey">
        <short>Interprets Enter as the default action, if applicable</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoReturnKey.AControl">
        <short>The control receiving the key</short>
      </element>
      <element name="TApplication.DoReturnKey.Key">
        <short>The virtual key; becomes VK_UNKNOWN when handled</short>
      </element>
      <element name="TApplication.DoReturnKey.Shift">
        <short>The active modifier keys</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Active">
        <short>True if the application has the focus</short>
        <descr/>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ApplicationType">
        <short>
          The type of the application (i.e. the sort of device for which it is intended)
        </short>
        <descr>
          <p>The type of the application:</p>
          <p>Default, Desktop, Handheld, PDA, Smartphone</p>
        </descr>
        <seealso/>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.BidiMode">
        <short>The bidirectional mode to use</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.CaptureExceptions">
        <short>Enables exception handling by Application</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.DoubleBuffered">
        <short>Indicates if the application uses double buffering</short>
        <descr>Default value is adbDefault. Hint: platform specific.</descr>
        <seealso></seealso>
      </element>
      <element name="TApplication.ExtendedKeysSupport">
        <short></short>
        <descr>See VK_LSHIFT in LCLType for more details.</descr>
        <seealso></seealso>
      </element>
      <element name="TApplication.ExceptionDialog">
        <short>Indicates the dialog type used for an exception in the application</short>
        <descr>
          <p>
            <var>ExceptionDialog</var> is a <var>TApplicationExceptionDlg</var> property which indicates the dialog type displayed for an exception handled by the application instance. The default value for the property is <var>aedOkCancelDialog</var>, as assigned in the <var>Create</var> constructor.
          </p>
          <p>
            See TApplicationExceptionDlg for more information about values in the enumeration and their meanings.
          </p>
        </descr>
        <seealso>
          <link id="TApplicationExceptionDlg"/>
          <link id="TApplication.Create"/>
          <link id="TApplicationProperties.ExceptionDialog"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.FindGlobalComponentEnabled">
        <short>Enables searching for global components by name</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Flags">
        <short>Application state flags</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.Handle">
        <short>Provides access to the widget set handle for the application instance</short>
        <descr>
          <p>
            <var>Handle</var> is a <var>THandle</var> property which provides access to the widget set handle used for the application instance. Reading the value for the property is redirected to the AppHandle allocated in the widget set class. Setting the value for the property causes the AppHandle in the widget set class to be updated with the new value.
          </p>
          <p>
            Handle is used to send and receive window messages and state change notifications for the application instance using the <b>LCL</b> interface.
          </p>
        </descr>
        <seealso>
          <link id="TWidgetSet.AppHandle"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Hint">
        <short>The current Hint text</short>
        <descr>
          <p>
            A hint is a pop-up message that appears briefly while the mouse hovers over a control. It usually displays useful information about how to the UI element, or the type of data that should be entered, etc.
          </p>
          <p>
            Other properties can be used to customize the delay before a Hint is shown, after the mouse is moved away from the control or form, and how long it will remain visible.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.HintPause"/>
          <link id="TApplication.HintHidePause"/>
          <link id="TApplication.HintHidePausePerChar"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintColor">
        <short>The color of Hint windows</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintHidePause">
        <short>How long a Hint stays visible, after an mouse move</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintHidePausePerChar">
        <short>
          How long a keystroke extends the time a Hint remains visible (added to HintHidePause)
        </short>
        <descr/>
        <seealso>
          <link id="TApplication.HintHidePause"/>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintPause">
        <short>The delay before a Hint is shown</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintShortCuts">
        <short>Enables the display of keyboard shortcuts (e.g. on menu entries)</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
        <notes><note>not implemented?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.HintShortPause">
        <short>The pause before a different Hint is displayed</short>
        <descr/>
        <seealso>
          <link id="TApplication.Hint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Icon">
        <short>The icon associated with this application</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.LayoutAdjustmentPolicy">
        <short>
          Indicates the layout and sizing policy used for forms and controls in the application
        </short>
        <descr></descr>
        <seealso>
          <link id="TLayoutAdjustmentPolicy"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.Navigation">
        <short>Allows to switch between controls by pressing keys</short>
        <descr>
          <p>These keys can be enabled for navigation:</p>
          <ul>
            <li>The Tab key moves the Focus to the next (or previous) control
              in TabOrder.</li>
            <li>The Enter key triggers the default action.</li>
            <li>The Escape key triggers the Cancel action.</li>
            <li>The F1 key brings up context sensitive help.</li>
            <li>The Arrow keys move the focus.</li>
          </ul>
        </descr>
        <seealso>
          <link id="TApplicationNavigationOptions"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.MainForm">
        <short>The application terminates when this form is closed.
        </short>
        <seealso/>
      <descr>
        <p>
          This property is set when the first form is created via Application.CreateForm and it is not FormStyle=fsSplash.
        </p>
      </descr>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.MainFormHandle">
        <short>The Handle of the MainForm</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplication.OnGetMainFormHandle"/>
          <link id="TApplicationHandlerType.ahtGetMainFormHandle"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.MainFormOnTaskBar">
        <short>
        </short>
        <descr>
        </descr>
        <seealso>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ModalLevel">
        <short>The number of modal forms shown</short>
        <descr>Tracks modal forms showing another form modally.
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TApplication.MoveFormFocusToChildren">
        <short>Indicates if an active control is focused when a form receives focus</short>
        <descr>
          <p>
            MoveFormFocusToChildren is a Boolean property which indicates if an active control is focused when a form receives focus in the application.
          </p>
          <p>
            The default value is True. When set to False, the window or form will still receive focus, but a child control is not selected.
          </p>
           <p>Used in TCustomForm.SetActive.</p>
        </descr>
        <seealso>
          <link id="TCustomForm.SetActive"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.MouseControl">
        <short>The control currently under the mouse</short>
        <descr>Used to detect mouse entering and leaving a control.
        </descr>
        <seealso>
        </seealso>
      </element>
      <element name="TApplication.TaskBarBehavior">
        <short>How forms are represented in the TaskBar</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TApplication.UpdateFormatSettings">
        <short>
          Indicates if application format settings are updated when changed in a widget set class
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnActionExecute">
        <short>Default handler for unhandled Actions</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnActionUpdate">
        <short>Default handler for unhandled Action updates</short>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnActivate">
        <short>Event handler for activation of the application</short>
        <seealso>
          <link id="TApplicationHandlerType.ahtActivate"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnDeactivate">
        <short>Event handler for deactivation of the application</short>
        <seealso>
          <link id="TApplicationHandlerType.ahtDeactivate"/>
        </seealso>
      </element>
      <element name="TApplication.OnGetMainFormHandle">
        <short>
          Event handler used to provide a value for the MainFormHandle property
        </short>
        <descr>
          <p>
            Used in the implementation of the <var>GetMainFormHandle</var> method. Provides the first opportunity to set the handle value before calling the other handlers added to the application.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.MainFormHandle"/>
          <link id="TApplication.GetMainFormHandle"/>
          <link id="TApplication.MainForm"/>
          <link id="TApplication.AddHandler"/>
          <link id="TApplicationHandlerType.ahtGetMainFormHandle"/>
        </seealso>
      </element>
      <element name="TApplication.OnIdle">
        <short>Event handler for application entering Idle state</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtIdle"/>
        </seealso>
      </element>
      <element name="TApplication.OnIdleEnd">
        <short>Event handler for application leaving Idle state</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtIdleEnd"/>
        </seealso>
      </element>
      <element name="TApplication.OnEndSession">
        <short>Event handler for ending a session of the application</short>
        <seealso>
          <link id="TApplicationHandlerType.ahtEndSession"/>
        </seealso>
        <notes><note>or logoff?</note></notes>
      </element>
      <element name="TApplication.OnQueryEndSession">
        <short>This event handler can deny to end the session</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtQueryEndSession"/>
        </seealso>
      </element>
      <element name="TApplication.OnMinimize">
        <short>Event handler for application minimized</short>
      </element>
      <element name="TApplication.OnMessageDialogFinished">
        <short>
          Event handler signalled when a message dialog in the application has been completed
        </short>
        <descr>Used in the CustomDraw interface.</descr>
        <seealso></seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnModalBegin">
        <short>Event handler for a modal form opened (application entering modal mode)</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplicationHandlerType.ahtModalBegin"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnModalEnd">
        <short>Event handler for closing modal forms (application exiting modal mode)</short>
        <descr>
        </descr>
        <seealso>
          <link id="TApplicationHandlerType.ahtModalEnd"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnRestore">
        <short>Event handler for application restored (from minimized/maximized state)</short>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnDropFiles">
        <short>The default handler for dropped files</short>
        <seealso>
          <link id="TCustomForm.OnDropFiles"/>
          <link id="TCustomForm.AllowDropFiles"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnHelp">
        <short>Event handler when help is requested</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtHelp"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnHint">
        <short>Event handler when a hint is requested</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtHint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnShortcut">
        <short>This event handler can interpret keystrokes as shortcuts,
          before the normal target handles the key</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtKeyDownBefore"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnShowHint">
        <short>Event handler for showing an Hint</short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtShowHint"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnUserInput">
        <short>
          Event handler signalled for application handler notifications for user input messages
        </short>
        <descr/>
        <seealso>
          <link id="TApplicationHandlerType.ahtUserInput"/>
          <link id="TApplication.NotifyUserInputHandler"/>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.OnDestroy">
        <short>Event handler signalled when the application is freed</short>
        <descr>
          <p>
            <var>OnDestroy</var> is signalled from the <var>Destroy</var> destructor prior to freeing resources allocated in the application class instance. It provides the first opportunity to respond to application shutdown after <var>Flags</var> has been updated to include the <var>AppDestroying</var> enumeration value.
         </p>
        </descr>
        <seealso>
          <link id="TApplication.Destroy"/>
          <link id="TApplication.Flags"/>
          <link id="TApplicationFlags"/>
        </seealso>
    </element>
    <element name="TApplication.OnCircularException">
      <short>
        Handler invoked when there a circular exception occurs before the application is halted.
      </short>
      <descr></descr>
      <seealso></seealso>
    </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ShowButtonGlyphs">
        <short>Allows to override the platform default for glyphs on buttons</short>
        <descr>Some platforms show glyphs on all buttons, others don't.</descr>
        <seealso>
        </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ShowMenuGlyphs">
        <short>Sets the default policy for showing or hiding glyph images in menus</short>
        <descr></descr>
        <seealso>
          <link id="#LCL.Menus.TGlyphShowMode"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
        <!-- property Visibility: public -->
        <element name="TApplication.ShowHint">
          <short>Indicates if Hints are displayed for the application</short>
          <descr>
            <p>
              <var>ShowHint</var> is a <var>Boolean</var> property which indicates if <var>Hints</var> are displayed for the application. It is used when tracking the position of the mouse cursor over controls and forms, and determines if the items require a hint display.
            </p>
            <p>
              Setting the value in <var>ShowHints</var> to <b>False</b> causes an existing <var>THintWindow</var> instance in the application to be freed.
            </p>
          </descr>
          <seealso>
            <link id="TApplicationProperties.ShowHint"/>
            <link id="TCustomForm.ShowHint"/>
            <link id="TControl.ParentShowHint"/>
            <link id="THintWindow"/>
          </seealso>
      </element>
      <!-- property Visibility: public -->
      <element name="TApplication.ShowMainForm">
        <short>
          Allows the main form to be shown or hidden when an application is started.
          Default is True.
        </short>
        <descr/>
        <seealso/>
      </element>
      <element name="TApplication.Title" link="#fcl.CustApp.TCustomApplication.Title"/>
      <element name="TApplication.Scaled">
        <short>
          Indicates if forms and controls in the application can be scaled to different display densities (Pixels per Inch)
        </short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="DefaultApplicationBiDiMode">
        <short>Contains the default BiDiMode value used for the current LCL version</short>
        <descr>Default value is bdLeftToRight. </descr>
        <seealso></seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintColor">
        <short>The default hint window color</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintPause">
        <short>The default pause before the hint window displays (in milliseconds)</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintShortPause">
        <short>The default Hint reshow pause (in milliseconds)</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintHidePause">
        <short>The default pause before hint is hidden (in milliseconds)</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefHintHidePausePerChar">
        <short>The default pause added to DefHintHidePause (in milliseconds)</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <!-- object Visibility: default -->
      <element name="TApplicationProperties">
        <short>
          A component that provides access to the properties for the current application
        </short>
        <descr>
          <p>
            <var>TApplicationProperties</var> is a non-visual component that provides access to a number of application properties, including:
          </p>
          <ul>
            <li>CaptureExceptions</li>
            <li>HelpFile</li>
            <li>Hint</li>
            <li>HintColor</li>
            <li>HintHidePause</li>
            <li>HintPause</li>
            <li>HintShortCuts</li>
            <li>HintShortPause</li>
            <li>ShowButtonGlyphs</li>
            <li>ShowMenuGlyphs</li>
            <li>ShowHint</li>
            <li>ShowMainForm</li>
            <li>Title</li>
            <li>OnException</li>
            <li>OnGetMainFormHandle</li>
            <li>OnIdle</li>
            <li>OnIdleEnd</li>
            <li>OnEndSession</li>
            <li>OnQueryEndSession</li>
            <li>OnMinimize</li>
            <li>OnModalBegin</li>
            <li>OnModalEnd</li>
            <li>OnRestore</li>
            <li>OnDropFiles</li>
            <li>OnHelp</li>
            <li>OnHint</li>
            <li>OnShowHint</li>
            <li>OnUserInput</li>
          </ul>
          <p>
            Values for the properties are assigned in the constructor to the currently assigned values in the <var>Application</var> singleton.
          </p>
          <p>
            At run-time, changes to the properties are also assigned to the <var>Application</var> singleton. For event handler properties, the previous routine is removed as a handler and the new handler is added to the <var>Application</var> singleton. When the component is freed, the event handlers are removed from the <var>Application</var> singleton. The changed properties are not assigned to <var>Application</var> at design-time.
          </p>
          <p>
            <var>TApplicationProperties</var> is available on the <b>Additional</b> tab in the Lazarus IDE Component Palette. <var>TApplicationProperties</var> is similar to the TApplicationEvents class in Delphi.
          </p>
        </descr>
        <seealso>
          <link id="TApplicationProperties.Create"/>
          <link id="TApplication"/>
          <link id="Application"/>
        </seealso>
      </element>
      <!-- variable Visibility: private -->
      <element name="TApplicationProperties.FCaptureExceptions" link="TApplicationProperties.CaptureExceptions"/>
      <element name="TApplicationProperties.FExceptionDialogType"/>
      <element name="TApplicationProperties.FHelpFile" link="TApplicationProperties.HelpFile"/>
      <element name="TApplicationProperties.FHint" link="TApplicationProperties.Hint"/>
      <element name="TApplicationProperties.FHintColor" link="TApplicationProperties.HintColor"/>
      <element name="TApplicationProperties.FHintHidePause" link="TApplicationProperties.HintHidePause"/>
      <element name="TApplicationProperties.FHintPause" link="TApplicationProperties.HintPause"/>
      <element name="TApplicationProperties.FHintShortCuts" link="TApplicationProperties.HintShortCuts"/>
      <element name="TApplicationProperties.FHintShortPause" link="TApplicationProperties.HintShortPause"/>
      <element name="TApplicationProperties.FOnActivate"/>
      <element name="TApplicationProperties.FOnDeactivate"/>
      <element name="TApplicationProperties.FOnDropFiles" link="TApplicationProperties.OnDropFiles"/>
      <element name="TApplicationProperties.FOnGetMainFormHandle" link="TApplicationProperties.OnGetMainFormHandle"/>
      <element name="TApplicationProperties.FOnModalBegin" link="TApplicationProperties.OnModalBegin"/>
      <element name="TApplicationProperties.FOnModalEnd" link="TApplicationProperties.OnModalEnd"/>
      <element name="TApplicationProperties.FShowButtonGlyphs" link="TApplicationProperties.ShowButtonGlyphs"/>
      <element name="TApplicationProperties.FShowHint" link="TApplicationProperties.ShowHint"/>
      <element name="TApplicationProperties.FShowMainForm" link="TApplicationProperties.ShowMainForm"/>
      <element name="TApplicationProperties.FShowMenuGlyphs" link="TApplicationProperties.ShowMenuGlyphs"/>
      <element name="TApplicationProperties.FTitle" link="TApplicationProperties.Title"/>
      <element name="TApplicationProperties.FOnException" link="TApplicationProperties.OnException"/>
      <element name="TApplicationProperties.FOnIdle" link="TApplicationProperties.OnIdle"/>
      <element name="TApplicationProperties.FOnIdleEnd" link="TApplicationProperties.OnIdleEnd"/>
      <element name="TApplicationProperties.FOnHelp" link="TApplicationProperties.OnHelp"/>
      <element name="TApplicationProperties.FOnHint" link="TApplicationProperties.OnHint"/>
      <element name="TApplicationProperties.FOnShowHint" link="TApplicationProperties.OnShowHint"/>
      <element name="TApplicationProperties.FOnUserInput" link="TApplicationProperties.OnUserInput"/>
      <element name="TApplicationProperties.FOnEndSession" link="TApplicationProperties.OnEndSession"/>
      <element name="TApplicationProperties.FOnQueryEndSession" link="TApplicationProperties.OnQueryEndSession"/>
      <element name="TApplicationProperties.FOnMinimize" link="TApplicationProperties.OnMinimize"/>
      <element name="TApplicationProperties.FOnRestore" link="TApplicationProperties.OnRestore"/>
      <element name="TApplicationProperties.SetExceptionDialog">
        <short>Sets the value for the ExceptionDialog property</short>
        <descr></descr>
        <seealso>
          <link id="TApplicationProperties.ExceptionDialog"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetExceptionDialog.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetCaptureExceptions">
        <short>Sets the value for the CaptureExceptions property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.CaptureExceptions"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetCaptureExceptions.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHelpFile">
        <short>Sets the value for the HelpFile property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HelpFile"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHelpFile.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHint">
        <short>Sets the value for the Hint property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.Hint"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHint.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintColor">
        <short>Sets the value for the HintColor property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintColor"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintColor.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintHidePause">
        <short>Sets the value for the HintHidePause property</short>
        <descr></descr>
        <seealso>
          <link id="TApplicationProperties.HintHidePause"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintHidePause.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintPause">
        <short>Sets the value for the HintPause property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintPause"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintPause.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintShortCuts">
        <short>Sets the value for the HintShortCuts property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintShortCuts"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintShortCuts.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetHintShortPause">
        <short>Sets the value for the HintShortPause property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.HintShortPause"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetHintShortPause.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetShowButtonGlyphs">
        <short>Sets the value for the ShowButtonGlyphs property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ShowButtonGlyphs"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetShowButtonGlyphs.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetShowMenuGlyphs">
        <short>Sets the value for the ShowMenuGlyphs property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ShowMenuGlyphs"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetShowMenuGlyphs.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetShowHint">
        <short>Sets the value for the ShowHint property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ShowHint"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetShowHint.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetShowMainForm">
        <short>Sets the value for the ShowMainForm property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.ShowMainForm"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetShowMainForm.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetTitle">
        <short>Sets the value for the Title property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.Title"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetTitle.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TApplicationProperties.SetOnActivate">
        <short>Sets the value for the OnActivate property</short>
        <descr></descr>
        <seealso>
          <link id="TApplicationProperties.OnActivate"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnActivate.AValue">
        <short>New value for the property</short>
      </element>
      <element name="TApplicationProperties.SetOnDeactivate">
        <short>Sets the value for the OnDeactivate property</short>
        <descr></descr>
        <seealso>
          <link id="TApplicationProperties.OnDeactivate"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnDeactivate.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnException">
        <short>Sets the value for the OnException property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnException"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnException.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnGetMainFormHandle">
        <short>Sets the value for the OnGetMainFormHandle property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnGetMainFormHandle"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnGetMainFormHandle.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnIdle">
        <short>Sets the value for the OnIdle property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnIdle"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnIdle.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnIdleEnd">
        <short>Sets the value for the OnIdleEnd property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnIdleEnd"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnIdleEnd.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnEndSession">
        <short>Sets the value for the OnEndSession property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnEndSession"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnEndSession.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnQueryEndSession">
        <short>Sets the value for the OnQueryEndSession property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnQueryEndSession"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnQueryEndSession.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnMinimize">
        <short>Sets the value for the OnMinimize property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnMinimize"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnMinimize.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnModalBegin">
        <short>Sets the value for the OnModalBegin property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnModalBegin"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnModalBegin.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnModalEnd">
        <short>Sets the value for the OnModalEnd property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnModalEnd"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnModalEnd.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnRestore">
        <short>Sets the value for the OnRestore property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnRestore"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnRestore.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnDropFiles">
        <short>Sets the value for the OnDropFiles property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnDropFiles"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnDropFiles.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnHelp">
        <short>Sets the value for the OnHelp property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnHelp"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnHelp.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnHint">
        <short>Sets the value for the OnHint property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnHint"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnHint.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnShowHint">
        <short>Sets the value for the OnShowHint property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnShowHint"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnShowHint.AValue">
        <short>New value for the property</short>
      </element>
      <!-- procedure Visibility: protected -->
      <element name="TApplicationProperties.SetOnUserInput">
        <short>Sets the value for the OnUserInput property</short>
        <descr/>
        <seealso>
          <link id="TApplicationProperties.OnUserInput"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.SetOnUserInput.AValue">
        <short>New value for the property</short>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TApplicationProperties.Create">
        <short>Constructor for the class instance</short>
        <descr>
          <p>
            <var>Create</var> is the constructor for TApplicationProperties. Create calls the inherited <var>Create</var> method, and sets the defaults values when a new application is being designed, or loads local values for an existing application.
          </p>
        </descr>
        <seealso>
          <link id="#rtl.Classes.TComponent.Create">TComponent.Create</link>
          <link id="#LCL.LCLClasses.TLCLComponent.Create">TLCLComponent.Create</link>
        </seealso>
      </element>
      <element name="TApplicationProperties.Create.AOwner">
        <short>Owner of the class instance</short>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TApplicationProperties.Destroy">
        <short>Destructor for the class instance</short>
        <descr>
          <p>
            <var>Destroy</var> is the overridden destructor for the class instance. <var>Destroy</var> ensures that event handlers in the class instance are removed from the handlers registered in the global <var>TApplication</var> instance.
          </p>
          <remark>
            Please note: Event handlers are not removed from the Application variable at design-time; they were not added at design-time either.
          </remark>
         <p>
           <var>Destroy</var> calls the inherited destructor prior to exiting from the method.
         </p>
        </descr>
        <seealso>
          <link id="TApplicationProperties.OnActivate"/>
          <link id="TApplicationProperties.OnDeactivate"/>
          <link id="TApplicationProperties.OnException"/>
          <link id="TApplicationProperties.OnGetMainFormHandle"/>
          <link id="TApplicationProperties.OnIdle"/>
          <link id="TApplicationProperties.OnIdleEnd"/>
          <link id="TApplicationProperties.OnEndSession"/>
          <link id="TApplicationProperties.OnQueryEndSession"/>
          <link id="TApplicationProperties.OnMinimize"/>
          <link id="TApplicationProperties.OnModalBegin"/>
          <link id="TApplicationProperties.OnModalEnd"/>
          <link id="TApplicationProperties.OnRestore"/>
          <link id="TApplicationProperties.OnDropFiles"/>
          <link id="TApplicationProperties.OnHelp"/>
          <link id="TApplicationProperties.OnHint"/>
          <link id="TApplicationProperties.OnShowHint"/>
          <link id="TApplicationProperties.OnUserInput"/>
        </seealso>
      </element>
      <element name="TApplicationProperties.CaptureExceptions" link="TApplication.CaptureExceptions"/>
      <element name="TApplicationProperties.ExceptionDialog">
        <short>Indicates the dialog type displayed for an exception</short>
        <descr>The default value is aedOkCancelDialog.</descr>
        <seealso></seealso>
      </element>
      <element name="TApplicationProperties.HelpFile" link="TApplication.HelpFile"/>
      <element name="TApplicationProperties.Hint" link="TApplication.Hint"/>
      <element name="TApplicationProperties.HintColor" link="TApplication.HintColor"/>
      <element name="TApplicationProperties.HintHidePause" link="TApplication.HintHidePause"/>
      <element name="TApplicationProperties.HintPause" link="TApplication.HintPause"/>
      <element name="TApplicationProperties.HintShortCuts" link="TApplication.HintShortCuts"/>
      <element name="TApplicationProperties.HintShortPause" link="TApplication.HintShortPause"/>
      <element name="TApplicationProperties.ShowButtonGlyphs" link="TApplication.ShowButtonGlyphs"/>
      <element name="TApplicationProperties.ShowMenuGlyphs" link="TApplication.ShowMenuGlyphs"/>
      <element name="TApplicationProperties.ShowHint" link="TApplication.ShowHint"/>
      <element name="TApplicationProperties.ShowMainForm" link="TApplication.ShowMainForm"/>
      <element name="TApplicationProperties.Title" link="TApplication.Title"/>
      <element name="TApplicationProperties.OnActivate" link="TApplication.OnActivate">
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TApplicationProperties.OnDeactivate" link="TApplication.OnDeactivate">
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="TApplicationProperties.OnException" link="TApplication.OnException"/>
      <element name="TApplicationProperties.OnGetMainFormHandle" link="TApplication.OnGetMainFormHandle"/>
      <element name="TApplicationProperties.OnIdle" link="TApplication.OnIdle"/>
      <element name="TApplicationProperties.OnIdleEnd" link="TApplication.OnIdleEnd"/>
      <element name="TApplicationProperties.OnEndSession" link="TApplication.OnEndSession"/>
      <element name="TApplicationProperties.OnQueryEndSession" link="TApplication.OnQueryEndSession"/>
      <element name="TApplicationProperties.OnMinimize" link="TApplication.OnMinimize"/>
      <element name="TApplicationProperties.OnModalBegin" link="TApplication.OnModalBegin"/>
      <element name="TApplicationProperties.OnModalEnd" link="TApplication.OnModalEnd"/>
      <element name="TApplicationProperties.OnRestore" link="TApplication.OnRestore"/>
      <element name="TApplicationProperties.OnDropFiles" link="TApplication.OnDropFiles"/>
      <element name="TApplicationProperties.OnHelp" link="TApplication.OnHelp"/>
      <element name="TApplicationProperties.OnHint" link="TApplication.OnHint"/>
      <element name="TApplicationProperties.OnShowHint" link="TApplication.OnShowHint"/>
      <element name="TApplicationProperties.OnUserInput" link="TApplication.OnUserInput"/>
      <!-- object Visibility: default -->
      <element name="TIDesigner">
        <short>The abstract base class for visual Form designers</short>
        <descr>
          <p>
            <var>TIDesigner</var> is a <var>TObject</var> descendant which specifies the interface used for visual Form designers . TIDesigner is the type used for the <var>TCustomForm.Designer</var> property.
          </p>
          <p>
            It is used as the ancestor for <var>TComponentEditorDesigner</var>, and the type expected in the RootDesigner for the Object Inspector and Property editors used in the Lazarus IDE.
          </p>
        </descr>
        <seealso>
          <link id="TCustomForm.Designer"/>
          <link id="FindRootDesigner"/>
        </seealso>
      </element>
      <!-- function Visibility: public -->
      <element name="TIDesigner.IsDesignMsg">
        <short>
          <var>IsDesignMsg</var> - receives a message from Sender, and returns True if it is a design message</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TIDesigner.IsDesignMsg.Result">
        <short/>
      </element>
      <element name="TIDesigner.IsDesignMsg.Sender">
        <short/>
      </element>
      <element name="TIDesigner.IsDesignMsg.Message">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.Modified">
        <short>Method when design is <var>Modified</var>
        </short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.Notification">
        <short>
          <var>Notification</var> that the supplied Operation has been applied to the
          specified Component
        </short>
        <descr/>
        <seealso/>
        <notes><note>???</note></notes>
      </element>
      <element name="TIDesigner.Notification.AComponent">
        <short/>
      </element>
      <element name="TIDesigner.Notification.Operation">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.PaintGrid">
        <short>
          <var>PaintGrid</var> - method for painting the grid in the designer</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.ValidateRename">
        <short>
          <var>ValidateRename</var> - method to validate the Rename process</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TIDesigner.ValidateRename.AComponent">
        <short/>
      </element>
      <element name="TIDesigner.ValidateRename.CurName">
        <short/>
      </element>
      <element name="TIDesigner.ValidateRename.NewName">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIDesigner.GetShiftState">
        <short>
          <var>GetShiftState</var> - returns the value of the shift state (whether shifted, Cntl key, Alt key etc)</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TIDesigner.GetShiftState.Result">
        <short/>
      </element>
      <!-- procedure Visibility: public -->
      <element name="TIDesigner.SelectOnlyThisComponent">
        <short>
          <var>SelectOnlyThisComponent</var> - method to select only the current component in the designer</short>
        <descr/>
        <seealso/>
      </element>
      <element name="TIDesigner.SelectOnlyThisComponent.AComponent">
        <short/>
      </element>
      <!-- function Visibility: public -->
      <element name="TIDesigner.UniqueName">
        <short>
          <var>UniqueName</var> - returns a Unique name for the designer, using the BaseName as a starting point</short>
        <descr/>
        <seealso/>
      </element>
      <!-- function result Visibility: default -->
      <element name="TIDesigner.UniqueName.Result">
        <short/>
      </element>
      <element name="TIDesigner.UniqueName.BaseName">
        <short/>
      </element>
<!-- object Visibility: default -->
      <element name="TFormPropertyStorage">
        <short>
          <var>TFormPropertyStorage</var> - class for storage of a Form's properties</short>
        <descr/>
        <seealso/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFormPropertyStorage.FormCreate">
        <short></short>
        <descr>Calls the Restore method.</descr>
        <seealso></seealso>
      </element>
      <element name="TFormPropertyStorage.FormCreate.Sender">
        <short/>
      </element>
      <!-- procedure Visibility: private -->
      <element name="TFormPropertyStorage.FormClose">
        <short/>
        <descr/>
        <seealso/>
      </element>
      <element name="TFormPropertyStorage.FormClose.Sender">
        <short/>
      </element>
      <element name="TFormPropertyStorage.FormClose.CloseAction">
        <short/>
      </element>
      <!-- constructor Visibility: public -->
      <element name="TFormPropertyStorage.Create" link="#rtl.Classes.TComponent.Create"/>
      <element name="TFormPropertyStorage.Create.TheOwner">
        <short/>
      </element>
      <!-- destructor Visibility: public -->
      <element name="TFormPropertyStorage.Destroy" link="#rtl.Classes.TComponent.Destroy"/>
      <!-- function Visibility: default -->
      <element name="KeysToShiftState">
        <short>Converts modifier keys from the LParam of a
          mouse message to a TShiftState</short>
        <descr/>
        <seealso>
          <link id="#RTL.Classes.TShiftState"/>
          <link id="ShiftStateToKeys"/>
          <link id="KeyDataToShiftState"/>
          <link id="#LCL.LCLType.MK_Shift"/>
          <link id="#LCL.LCLType.MK_Control"/>
          <link id="#LCL.LCLType.MK_LButton"/>
          <link id="#LCL.LCLType.MK_RButton"/>
          <link id="#LCL.LCLType.MK_MButton"/>
          <link id="#LCL.LCLType.MK_XBUTTON1"/>
          <link id="#LCL.LCLType.MK_XBUTTON2"/>
        </seealso>
      </element>
      <element name="KeysToShiftState.Result">
        <short/>
      </element>
      <element name="KeysToShiftState.Keys">
        <short>The asynchronous keyboard state</short>
      </element>
      <!-- function Visibility: default -->
      <element name="KeyDataToShiftState">
        <short>
          Converts modifier keys from the LParam keyboard message (WM_KEYUP for
          example) to a TShiftState
        </short>
        <descr/>
        <seealso>
          <link id="#RTL.Classes.TShiftState"/>
          <link id="KeysToShiftState"/>
          <link id="ShiftStateToKeys"/>
          <link id="#LCL.LCLType.MK_Shift"/>
          <link id="#LCL.LCLType.MK_Control"/>
          <link id="#LCL.LCLType.MK_LButton"/>
          <link id="#LCL.LCLType.MK_RButton"/>
          <link id="#LCL.LCLType.MK_MButton"/>
          <link id="#LCL.LCLType.MK_XBUTTON1"/>
          <link id="#LCL.LCLType.MK_XBUTTON2"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="KeyDataToShiftState.Result">
        <short/>
      </element>
      <element name="KeyDataToShiftState.KeyData">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <!-- function Visibility: default -->
      <element name="ShiftStateToKeys">
        <short>
          Converts a shift state into a key state value compatible with the key state of a Windows API LParam
        </short>
        <descr>
          <p>
            The Keys value is of the type PtrUInt and is a or'ed combination of the following constants:
          </p>
          <ul>
            <li>MK_Shift</li>
            <li>MK_Control</li>
            <li>MK_LButton</li>
            <li>MK_RButton</li>
            <li>MK_MButton</li>
            <li>MK_XBUTTON1</li>
            <li>MK_XBUTTON2</li>
          </ul>
        </descr>
        <seealso>
          <link id="#RTL.Classes.TShiftState"/>
          <link id="KeysToShiftState"/>
          <link id="KeyDataToShiftState"/>
          <link id="#LCL.LCLType.MK_Shift"/>
          <link id="#LCL.LCLType.MK_Control"/>
          <link id="#LCL.LCLType.MK_LButton"/>
          <link id="#LCL.LCLType.MK_RButton"/>
          <link id="#LCL.LCLType.MK_MButton"/>
          <link id="#LCL.LCLType.MK_XBUTTON1"/>
          <link id="#LCL.LCLType.MK_XBUTTON2"/>
        </seealso>
        <notes><note>into what?</note></notes>
      </element>
      <element name="ShiftStateToKeys.Result">
        <short/>
        <notes><note>?</note></notes>
      </element>
      <element name="ShiftStateToKeys.ShiftState">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="WindowStateToStr">
        <short>
          <var>WindowStateToStr</var> - converts a Window state to a string</short>
        <descr/>
        <seealso/>
      </element>
      <element name="WindowStateToStr.Result">
        <short/>
      </element>
      <element name="WindowStateToStr.State">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="StrToWindowState">
        <short>
          <var>StrToWindowState</var> - converts a string to a Window state</short>
        <descr/>
        <seealso/>
      </element>
      <element name="StrToWindowState.Result">
        <short/>
      </element>
      <element name="StrToWindowState.Name">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="dbgs">
        <short>Formats various typed values into readable text</short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="dbgs.Result">
        <short>The formatted value</short>
      </element>
      <element name="dbgs.State">
        <short/>
      </element>
      <element name="dbgs.Action">
        <short/>
      </element>
      <element name="dbgs.Kind">
        <short/>
      </element>
<!-- alias type Visibility: default -->
      <element name="TFocusState">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- function Visibility: default -->
      <element name="SaveFocusState">
        <short>Returns the remembered control</short>
        <descr/>
        <seealso>
          <link id="RestoreFocusState"/>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <element name="SaveFocusState.Result">
        <short/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="RestoreFocusState">
        <short>Remembers the control in LastFocusedControl</short>
        <descr/>
        <seealso>
          <link id="SaveFocusState"/>
        </seealso>
      </element>
      <element name="RestoreFocusState.FocusState">
        <short/>
      </element>
      <!-- function type Visibility: default -->
      <element name="TGetDesignerFormEvent">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="TGetDesignerFormEvent.Result">
        <short/>
      </element>
      <element name="TGetDesignerFormEvent.APersistent">
        <short/>
      </element>
      <element name="TIsFormDesignFunction">
        <short></short>
        <descr>
          TIsFormDesignFunction is a Boolean function type used in the IsFormDesign variable.
        </descr>
        <seealso>
          <link id="IsFormDesign"/>
        </seealso>
      </element>
      <element name="TIsFormDesignFunction.Result">
        <short>Returns True when the form has csDesignInstance in its component state</short>
      </element>
      <element name="TIsFormDesignFunction.AForm">
        <short></short>
      </element>
      <!-- variable Visibility: default -->
      <element name="OnGetDesignerForm">
        <short/>
        <descr>
          OnGetDesignerForm is a TGetDesignerFormEvent variable that contains the event handler signalled to get a form with a design surface for the specified form or control.
        </descr>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <!-- function Visibility: default -->
      <element name="GetParentForm">
        <short>Gets the topmost Form containing the specified Control</short>
        <descr/>
        <seealso/>
      </element>
      <element name="GetParentForm.Result">
        <short/>
      </element>
      <element name="GetParentForm.Control">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetDesignerForm">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="GetDesignerForm.Result">
        <short/>
      </element>
      <element name="GetDesignerForm.Control">
        <short/>
      </element>
      <element name="GetDesignerForm.APersistent">
        <short/>
      </element>
      <!-- function Visibility: default -->
      <element name="GetFirstParentForm">
        <short>Does a recursive search for the first Parent of type TCustomForm</short>
        <descr/>
        <seealso/>
      </element>
      <element name="GetFirstParentForm.Result">
        <short/>
      </element>
      <element name="GetFirstParentForm.Control">
        <short/>
      </element>
      <element name="GetTopFormSkipNonDocked">
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="GetTopFormSkipNonDocked.Result">
        <short></short>
      </element>
      <element name="GetTopFormSkipNonDocked.Control">
        <short></short>
      </element>
      <element name="ValidParentForm">
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="ValidParentForm.Result">
        <short></short>
      </element>
      <element name="ValidParentForm.Control">
        <short></short>
      </element>
      <element name="ValidParentForm.TopForm">
        <short></short>
      </element>
      <!-- function Visibility: default -->
      <element name="FindRootDesigner">
        <short/>
        <descr/>
        <seealso/>
        <notes><note>?</note></notes>
      </element>
      <element name="FindRootDesigner.Result">
        <short/>
      </element>
      <element name="FindRootDesigner.APersistent">
        <short/>
      </element>
      <element name="GetParentDesignControl">
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="GetParentDesignControl.Result">
        <short></short>
      </element>
      <element name="GetParentDesignControl.Control">
        <short></short>
      </element>
      <element name="NeedParentDesignControl">
        <short></short>
        <descr></descr>
        <seealso></seealso>
      </element>
      <element name="NeedParentDesignControl.Result">
        <short></short>
      </element>
      <element name="NeedParentDesignControl.Control">
        <short></short>
      </element>
      <!-- function Visibility: default -->
      <element name="IsAccel">
        <short>Searches for the given virtual key, used as an accelerator</short>
        <descr>
          <p>
            An accelerator consists of an ampersand followed by the accelerator key. Duplicate ampersands are ignored; they denote a literal (displayed) ampersand character (<b>&amp;</b>).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="IsAccel.Result">
        <short>True when the key is used as an accelerator</short>
      </element>
      <element name="IsAccel.VK">
        <short>The virtual key (uppercase ASCII) to find</short>
      </element>
      <element name="IsAccel.Str">
        <short>The string to scan</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="NotifyApplicationUserInput">
        <short>Invokes all application user input handlers</short>
        <descr/>
        <seealso/>
      </element>
      <element name="NotifyApplicationUserInput.Msg">
        <short>The message to process</short>
      </element>
      <!-- function Visibility: default -->
      <element name="GetShortHint">
        <short>Returns the short version of a Hint string</short>
        <descr>
          <p>
            A short Hint is separated from the long Hint by a '|' character. When no such character is found, the whole Hint is returned.
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="GetShortHint.Result">
        <short>The short (or complete) Hint</short>
      </element>
      <element name="GetShortHint.Hint">
        <short>The string containing both a short and long Hint</short>
      </element>
      <!-- function Visibility: default -->
      <element name="GetLongHint">
        <short>Returns the long version of a Hint string</short>
        <descr/>
        <seealso>
          <link id="GetShortHint"/>
        </seealso>
      </element>
      <element name="GetLongHint.Result">
        <short/>
      </element>
      <element name="GetLongHint.Hint">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="Application">
        <short>The TApplication singleton</short>
        <descr/>
        <seealso>
          <link id="TApplication"/>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="Screen">
        <short>The TScreen singleton</short>
        <descr/>
        <seealso>
          <link id="TScreen"/>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="ExceptionObject">
        <short>Variable representing the current exception object in an application</short>
        <descr>
          <p>
            Used in the implementation of the TApplication.HandleException method.
          </p>
        </descr>
        <seealso>
          <link id="TApplication.HandleException"/>
        </seealso>
      </element>
      <!-- variable Visibility: default -->
      <element name="HintWindowClass">
        <short>The class used to create hint window instances for an application</short>
        <descr/>
        <seealso/>
      </element>
      <!-- variable Visibility: default -->
      <element name="RequireDerivedFormResource">
        <short>
          When True every form must have a resource (e.g. a .res file). An exception is raised if the resource is missing when creating a form.
        </short>
        <descr>
          <p>
            The form resource is the <file>.lfm</file> file compiled into the executable of your application. For this flag, it does not matter if it was compiled via an <file>.lrs</file> file or via <file>fpcres</file>. The resource is automatically loaded by <var>TForm</var> and its descendants when created using the   <code>Create(Owner)</code> method.
          </p>
          <p>
            If the resource file is missing, there is something wrong with either a resource or the unit which contains the faulty form. If the flag is False, you will see a blank form and probably search a long time what is wrong. If you set this flag to True, you get an exception.
          </p>
          <p>
            For creating forms without resources, you have 3 options:
          </p>
          <ul>
            <li>Create a TForm class (not a descendant).</li>
            <li>Construct your form using the CreateNew() constructor.</li>
            <li>It is also possible to disable the exception by setting the global
               variable RequireDerivedFormResource to False.</li>
          </ul>
          <p>
            History:
            Before 0.9.31 there was no exception. Therefore some resource-less forms
            might use the standard constructor Create(Owner) and will now get
            exceptions. This change is Delphi compatible and compatible with
            TFrame and TDataModule components.
          </p>
        </descr>
        <seealso>
        </seealso>
        <notes><note>?</note></notes>
      </element>
      <!-- function type Visibility: default -->
      <element name="TMessageBoxFunction">
        <short>The type used for the MessageBox variable</short>
        <descr>
          <p>
            TMessageBoxFunction is an Integer function type which specifies the routine used to perform a message box or dialog.
          </p>
          <p>
            Arguments passed to the function identify the content for the message dialog, including:
          </p>
          <ul>
            <li>Text displayed in the mesaage dialog</li>
            <li>Title used on dialog form</li>
            <li>Flag values that control the buttons and icon for the dialog</li>
          </ul>
          <p>
            The return value contains the modal result returned from the message dialog.
          </p>
        </descr>
        <seealso>
          <link id="MessageBoxFunction"/>
          <link id="DefaultMessageBox"/>
        </seealso>
      </element>
      <element name="TMessageBoxFunction.Result">
        <short/>
      </element>
      <element name="TMessageBoxFunction.Text">
      </element>
      <element name="TMessageBoxFunction.Caption">
        <short/>
      </element>
      <element name="TMessageBoxFunction.Flags">
        <short/>
      </element>
      <!-- variable Visibility: default -->
      <element name="MessageBoxFunction">
        <short>
          Provides the routine used to display a message dialog in widget set implementations
        </short>
        <descr>
          <p>
            Normally contains a reference to the <var>DefaultMessageBox</var> function. It may have another function reference assigned to the variable in specific widget set implementations (such as CustomDraw controls).
          </p>
        </descr>
        <seealso>
          <link id="#LCL.Dialogs.DefaultMessageBox"/>
        </seealso>
      </element>
      <!-- constant Visibility: default -->
      <element name="DefaultBorderIcons">
        <short>Maps form border styles to their border icons</short>
        <descr>
          <p>
            <var>DefaultBorderIcons</var> is an array constant with <var>TBorderIcons</var> values indicating the icons available for the various form border styles. Values in the array are indexed by the enumeration values in TFormBorderStyle. Each element in the array contains zero (0) or more values from the TBorderIcon enumeration, and indicates that the icon is used for the form border style.
          </p>
          <p>
            DefaultBorderIcons contains the following values for the corresponding TFormBorderStyle values:
          </p>
          <dl>
            <dt>bsNone</dt>
            <dd>An empty set ([])</dd>
            <dt>bsSingle</dt>
            <dd>[biSystemMenu, biMinimize]</dd>
            <dt>bsSizeable</dt>
            <dd>[biSystemMenu, biMinimize, biMaximize]</dd>
            <dt>bsDialog</dt>
            <dd>[biSystemMenu]</dd>
            <dt>bsToolWindow</dt>
            <dd>[biSystemMenu, biMinimize]</dd>
            <dt>bsSizeToolWin</dt>
            <dd>[biSystemMenu, biMinimize, biMaximize]</dd>
          </dl>
          <p>
            DefaultBorderIcons is used in the implementation of the SetFormBorderStyle method in TCustomForm.
          </p>
        </descr>
        <seealso/>
      </element>
      <!-- procedure Visibility: default -->
      <element name="CreateWidgetset">
        <short>Creates the widget set</short>
        <descr>
          <p>
            <var>CreateWidgetset</var> is a procedure used to create the <var>WidgetSet</var> singleton. CreateWidgetset executes the nitialization handlers for the LCL interface.
          </p>
          <p>
            <var>AWidgetsetClass</var> is the <var>TWidgetsetClass</var> class type used to create the <var>WidgetSet</var> singleton. CreateWidgetset is called from the <file>interfaces.pp</file> unit for a specific widget set implementation (win32, gtk, gtk2, gtk3, qt, qt5, et. al.).
          </p>
        </descr>
        <seealso/>
      </element>
      <element name="CreateWidgetset.AWidgetsetClass">
        <short>TWidgetsetClass class type for the desired widget set implementation</short>
      </element>
      <!-- procedure Visibility: default -->
      <element name="FreeWidgetSet">
        <short>Destroys singletons for the Screen, Application, and WidgetSet</short>
        <descr>
          <p>
            <var>FreeWidgetSet</var> is a procedure used to free resources allocated to the <var>Screen</var>, <var>Application</var>, <var>Clipboards</var>, and <var>WidgetSet</var> singletons.
          </p>
          <p>
            For Screen, allocated cursors and monitors are destroyed. Application is freed, and set to Nil. All clipboard formats are freed as well. The WidgetSet singleton is freed, and set to Nil.
          </p>
          <p>
            FreeWidgetSet executes the <var>CallInterfaceFinalizationHandlers</var> routine to perform any finalization handlers installed for the <b>LCL</b> interface.
          </p>
        </descr>
        <seealso>
          <link id="Application"/>
          <link id="Screen"/>
          <link id="WidgetSet"/>
          <link id="#LCL.LCLProc.CallInterfaceFinalizationHandlers"/>
        </seealso>
      </element>
      <!-- procedure Visibility: default -->
      <element name="Register">
        <short>Registers components declared in this unit</short>
        <descr>
          <p>
            <var>Register</var> is a procedure used to register components declared in the <file>forms.pp</file> unit for use in the Lazarus IDE. The <var>TFrame</var> component is added to the <b>Standard</b> tab. In addition, the <var>TScrollBox</var> and <var>TApplicationProperties</var> components are added to the <b>Additional</b> tab.
          </p>
        </descr>
        <seealso/>
      </element>
    </module>
    <!-- Forms -->
  </package>
</fpdoc-descriptions>
